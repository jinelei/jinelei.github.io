[{"title":"Spring Boot集成Flowable 备忘录","url":"/2020/10/22/flowable-memo/","content":"@Bean\npublic ProcessEngineFactoryBean processEngine(SpringProcessEngineConfiguration springProcessEngineConfiguration) {\n    ProcessEngineFactoryBean bean = new ProcessEngineFactoryBean();\n    springProcessEngineConfiguration\n            .setDataSource(flowableDataSource())\n            .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE)\n            .setActivityFontName(\"宋体\")\n            .setLabelFontName(\"宋体\")\n            .setAnnotationFontName(\"宋体\");\n    bean.setProcessEngineConfiguration(springProcessEngineConfiguration);\n    return bean;\n}\n```\n","tags":["学习笔记"],"categories":["Java","Flowable"]},{"title":"vSphere hypervisor 6.5安装","url":"/2018/12/29/vmware-sphere-install/","content":"\n1. #### 前置安装环境：\nwin7最好。\n\n1. #### 制作安装盘的准备工作：\n    2. 下载需要的软件包和镜像。\n\n    2. 在[vmware官网](https://www.vmware.com/cn.html)注册账号\n    ![download](/img/post/linux/vsphere_download.webp)\n    > 请记住这里的许可证密钥，安装完成后在web控制台需要。\n    > 点击下方的下载按钮，下载镜像文件i(VMware vSphere Hypervisor (ESXi ISO) image (Includes VMware Tools))。\n\n    2. [检查](https://vibsdepot.v-front.de/wiki/index.php/List_of_currently_available_ESXi_packages)自己的机器硬件，下载对应的驱动程序。\n\n    2. 下载[ESXi定制工具](https://www.v-front.de/p/esxi-customizer.html)，不支持win10。[如果硬件驱动均在官方镜像包中，则不需要定制镜像]\n        3. 解压ESXi定制工具。\n        3. 进入解压目录，双击执行脚本(ESXi-Customizer.cmd)。\n        3. Select the original VMware ESXi ISO: 选择官方的原始ISO。\n        3. Select an OEM.tgz file, a VIB file or an Offline Bundle: 选择自己机器需要添加的驱动程序。\n        3. select work directory: 选择输出目录。\n        3. 点击run按钮。\n        3. 忽略中途出现的警告，直至完成。\n\n\n\n\n1. #### 制作ESXi安装盘\n安装系统有很多种选择。\n- 例如大白菜等安装工具，选择安装自定义ISO。\n- 使用dd命令、UISO工具制作启动盘安装。\n\n1. #### 安装ESXi\n选择磁盘安装即可。无脑接受下一步，注意设置账户名和密码。\n安装完成后开机，显示器上会显示本机ip地址。\n\n1. #### 安装虚拟机（我这里使用ISO创建虚拟机）\n- 在浏览器中打开上一步得到的ip地址，进入web管理页面：\n- 输入账户、密码（安装时提示输入的）。\n- 点击左侧虚拟机，右键选择选择 创建/注册虚拟机。\n- 在弹出中选择 创建虚拟机。点击下一页。\n- 添加名称和操作系统系列和操作系统版本。点击下一页。\n- 选择存储类型和数据存储，选择需要的磁盘。点击下一页。\n- 创建自定义设置。磁盘、内存、在CD/DVD驱动中选择数据储存ISO文件。选择自己上传的ISO镜像即可（如果之前没有上传，在这里也可以执行上传操作）。点击下一页。\n- 确认配置后点击完成。\n- 在虚拟机中打开刚才自己创建的虚拟机。执行常规安装系统操作。\n\n1. #### 添加许可证。\n- 点击左侧主机下管理。选择许可tab页。\n- 点击分配许可证，在弹出框中输入自己账户的许可证，点击检查许可证。\n- 完成操作后，在许可tab页中会出现键信息。\n\n1. #### [可选的]设置静态ip。\n具体操作方法请参考相应系统设置。[centos7设置静态IP](https://jinelei.github.io/linux/2018/05/10/static-ip)\n\n","tags":["学习笔记"],"categories":["Linux"]},{"title":"plsql程序设计","url":"/2018/12/09/learn-plsql/","content":"\n1. 基本程序块\n\n```\nCREATE OR REPLACE FUNCTION wordcount(str IN VARCHAR2)\n    RETURN PLS_INTEGER\nAS\n    declare local variable here\nBEGIN\n    implement algorithm here\nEND;\n/\n```\n\n运行一个脚本，将上面代码保存为wordcount.fun，执行前可以将回显打开。\n\n```\nset echo on\n@wordcount.fun\n```\n\n","tags":["学习笔记"],"categories":["SQL"]},{"title":"NIO、AIO、BIO","url":"/2018/12/06/BIO-NIO-AIO/","content":"\n- ### 什么是BIO/AIO/NIO\n    - BIO（Blocking I/O）同步阻塞IO：这是最基本最简单的IO，特点是任务按顺序依次进行。  \n    - NIO（New I/O或者Non-Blocking I/O）同步非阻塞IO：NIO本身是基于事件驱动的，用来解决大并发问题。  \n    - AIO（Asynchronous I/O）异步非阻塞IO：在JDK7中实现，和NIO的区别是，NIO还需要使用轮询的方式来确定数据是否已经准备好，而AIO直接在数据准备好后通知使用者。这里的异步还与系统相关，在Unix/Linux下，使用epoll IO模型，在window下使用IOCP模型。  \n\n\n- ### NIO的组成\n    - Channel（通道）： 基本上所有的IO在NIO中都从一个Channel开始，类似于Stream，不过Channel是双向的。Channel有以下实现：    \t\t\n        -  FileChannel（从文件中读写数据）  \n        -  DatagramChannel（通过UDP读写网络中的数据）  \n        -  SocketChannel（通过TCP读写网络中的数据）  \n        -  ServerSocketChannel（监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel）  \n\t\t    \n    - Buffer（缓冲区）： 使用Buffer读写数据一般遵循一下4个步骤：    \n        - 写入数据到Buffer  \n        - 调用flip()方法：切换模式（读写模式）  \n        - 从Buffer中读取数据  \n        - 调用clear()方法或者compact()方法：（clear()方法会清空整个缓冲区，compact()方法只会清除已经读过的数据，任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面）  \n    - Selector（多路复用器）：Selector允许单线程处理多个Channel。要使用Selector，先得向Selector注册Channel，然后调用它的select()方法。    \n        - 创建Selector：```Selector selector = Selector.open();```\n        - 注册Channel：```channel.configureBlocking(false);\nSelectionKey key = channel.register(selector,  Selectionkey.OP_READ);```  \n- ### FileChannel示例：\n\n\t\t```\n\t\timport java.io.*;\n\t\timport java.nio.*;\n\t\timport java.nio.channels.*;\n\n\t\tpublic class FileChannelDemo {\n\t\t\t\tpublic static void main(String[] args) throws Exception{\n\t\t\t\t\t\tRandomAccessFile file = new RandomAccessFile(\"./data.txt\", \"rw\");\n\t\t\t\t\t\tFileChannel inChannel = file.getChannel();\n\t\t\t\t\t\tByteBuffer buf = ByteBuffer.allocate(48);\n\t\t\t\t\t\tint bytesRead = inChannel.read(buf);\n\t\t\t\t\t\twhile(bytesRead != -1){\n\t\t\t\t\t\t\t\tSystem.out.println(\"read: \" + bytesRead);\n\t\t\t\t\t\t\t\tbuf.flip();\n\t\t\t\t\t\t\t\twhile(buf.hasRemaining()){\n\t\t\t\t\t\t\t\t\t\tSystem.out.print((char)buf.get());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\t\tbuf.clear();\n\t\t\t\t\t\t\t\tbytesRead = inChannel.read(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfile.close();\n\t\t\t\t}\n\t\t}\n\t\t```\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java中的原子类","url":"/2018/12/05/atomic/","content":"\n从java5开始提供了```java.util.concurrnet.atomic```包，这个包中的院子操作类提供了简单、高效、线程安全的更新变量的方式。\n这个包中提供了13个类，属于4种原子更新方式：原子更新基本类型、原子更新数组、原子更新引用、原子更新属性。他们共同的特点是使用Unsafe实现的包装类。\n\n- ### 原子更新基本类型\n主要包括```AtomicBoolean、AtomicInteger、AtomicLong```，他们提供的方法大同小异。\n下面是AtomicInteger的主要方法：\n    - int addAndGet(int delta)：原子添加delta，返回新值\n    - boolean compareAndSet(int except, int update)：比较并更新，返回新值\n    - int getAndIncrement()：以原子的方式加1，返回之前的值\n    - void lazySet(int newValue)：更新后一点时间内，其他线程可能拿到旧值\n    - int getAndSet(int newValue)：原子方式更新newValue，返回旧值\n\n- ### 原子更新数组\n主要包括```AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray、```\n常用方法：\n    - int addAndGet(int i, int delta)：原子将输入值和数组索引i的元素相加\n    - boolean compareAndSet(int i, int expect, int update)：原子更新\n\n- ### 原子更新引用\n主要包括```AtomicReference（原子更新引用类型）、AtomicReferenceFieldUpdater（原子更新引用类型的字段）、AtomicMarkableReference（原子更新带有标记位的引用类型）```\n> AtomicMarkableReference(V initialRef, boolean initalMark)\n\n- ### 原子更新字段\n主要包括```AtomicIntegerFieldUpdater（原子更新整型字段）、AtomicLongFieldUpdater（原子更新长整型字段）、AtomicStampedReference（原子更新带有版本号的引用类型，可以用来解决ABA问题）```\n\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"Java中的阻塞队列","url":"/2018/12/05/block-queue/","content":"\n- ### 什么是阻塞队列\n阻塞队列是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。\n    1. 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入原色的线程，知道队列不满。\n    2. 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。  \n阻塞队列常用于生产者消费值场景，生产者向队列添加元素，消费值取出元素。  \n下面是插入和移除的4中处理方式\n\n| 方法/处理方式 | 抛出异常   | 返回特殊值 | 一直阻塞 | 超时退出           |\n| :---          | :---       | :---       | :---     | :---               |\n| 插入方法      | add(e)     | offer(e)   | put(e)   | offer(e,time,unit) |\n| 移除方法      | remove()   | poll()     | take()   | poll(time,unit)    |\n| 检查方法      | element(e) | peek()     | 不可用   | 不可用             |\n\n> - 抛出异常：当队列为满时抛出IllegalStateException(\"Queue full\")异常，当队列为空时抛出NoSuchElementException异常。\n> - 返回特殊值：插入元素时，会返回是否插入成功，移除时，返回取出的元素，没有则为null。\n> - 一直阻塞：插入元素时，如果队列为满会一直阻塞到队列不为满，移除元素时，如果队列为空，会阻塞到队列不为空。\n> - 超时退出：当发生插入移除阻塞时，达到最大阻塞时间后就会退出。\n>> 便于记忆：一直阻塞带t，返回特殊值带o。\n>>> 如果是无界阻塞队列，则put和take方法永不阻塞，offer方法永远为true。\n\n- ### JDK7中的7种阻塞队列\n    - ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列\n    - LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列\n    - PriorityBlockingQueue：一个支持优先级的无界阻塞队列\n    - DelayQueue：一个由PriorityBlockQueue实现的无界阻塞队列\n    - SynchronousQueue：一个不存储元素的阻塞队列\n    - LinkedTransferQueue：一个由链表结构组成的无界阻塞队列\n    - LinkedBlockingDuque：一个由链表结构组成的双向阻塞队列\n\n- #### ArrayBlockingQueue\n此队列按照FIFO原则对元素进行排序。默认情况下不保证所有线程公平访问队列，可以使用一下代码创建公平的阻塞队列```ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000, true);```，因为公平性是由ReentrantLock实现的\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair){\n    if(capacity < 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair); // 此处设置公平性\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n```\n\n- #### LinkedBlockingQueue\n此阻塞队列最大长度和默认长度为Integer.MAX_VALUE，遵循FIFO。\n\n- #### PriorityBlockingQueue\n这是一个支持优先级的无界阻塞队列。默认情况下采取自然排序，也可以重写compareTo方法来指定排序规则。或者初始化时指定Comparator。需要注意的是不能保证同级别的排序。\n\n- #### DelayQueue\n这是一个支持延时获取元素的无界阻塞队列。使用PriorityBlockingQueue实现，队列元素必须实现Delayed接口，在创建元素是可以指定多长时间后才能获取元素，只有延时期满才能获取元素。\n> 它有以下使用场景  \n> 缓存系统：将元素存入延迟阻塞队列，使用一个线程来获取元素，当元素能够获取到，则说明该元素已经过期。  \n> 定时任务：将任务存入延迟阻塞队列，使用一个线程来获取元素，获取到就去执行任务。\n\n- #### SynchronousQueue\n这是一个不存储元素的阻塞队列，每一个put操作鼻血等待take操作。因此它的吞吐量比其他的阻塞队列高\n\n- #### LinkedTransferQueue\nLinkedTransferQueue比LinkedBlockingQueue多了tryTransfer和transfer方法。\n    - trnasfer方法会尝试把接收到的数据直接transfer给其他正在等待的线程，如果没有等待线程它会自旋一段时间，超时后出让CPU时间。\n    - tryTransfer方法会立即返回，如果有消费者等待的话返回true，否则false。transfer则必须等待消费者消费了才能返回。\n\n- #### LinkedBlockingDeque\n这是一个双向队列，比LinkedBlockingQueue多了addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast等方法。\n在初始化LinkedBlockingDeque可以设置它的厨师容量以防止其过度膨胀，双向队列可以工作在“窃取模式”。\n\n- ### 阻塞队列的实现原理\n    - 使用通知模式实现：原理可见之前Lock和Condition部分。\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java中的Fork/Join框架","url":"/2018/12/05/fork-join/","content":"\nFork/Join框架是Java7中新增的用于并行执行任务的框架，把一个大的任务分割成小任务，最后汇总得到运行结果。  \n\n- ### 工作窃取算法\n把大任务分割成小任务后，有些线程执行完成后，其他线程可能还没有执行完成，这时候，执行完成的线程可以帮助未执行完线程执行任务，这就是工作窃取。核心在与怎么样避免冲突，这时候双向阻塞队列就发挥了作用，正常工作的线程永远从队列头取任务，窃取线程从队列尾取任务。\n\n- ### Fork/Join框架的设计\n    - #### 任务分割\n    首先我们要把大任务分割成小任务。有些可能要递归的分割，知道足够小。\n    - #### 执行任务并合并结果\n    分割的子任务放在双向队列的两端，然后启动几个线程从队列中取任务，子任务运行结果都放在一个队列里，再启动一个线程从结果队列中取数据和合并数据。\nFork/Join框架使用两个类来完成上面的事情：ForkJoinTask、ForkJoinPool。\n    - ForkJoinTask：提供了两个子类来完成分割任务和合并任务的事情。RecursiveAction（用于没有任务返回结果）、RecursiveTask（用于有任务返回结果）。\n    - ForkJoinPool：ForkJoinTask需要通过ForkJoinPool执行。\n\n```java\nimport java.util.concurrent.*;\n\npublic class CountTask extends RecursiveTask<Integer> {\n    private static final int THRESHOLD = 2; // 阈值\n    private int start;\n    private int end;\n    public CountTask(int start, int end){\n        this.start = start;\n        this.end = end;\n    }\n    @Override\n    protected Integer compute(){\n        int sum = 0;\n        boolean canCompute = (end - start) <= THRESHOLD;\n        if(canCompute){\n            for(int i = start; i <= end; i++){\n                sum += i;\n            }\n        }else{\n            int middle = (end + start) / 2;\n            CountTask leftTask = new CountTask(start, middle);\n            CountTask rightTask = new CountTask(middle + 1, end);\n            leftTask.fork();\n            rightTask.fork();\n            int leftResult = leftTask.join();\n            int rightResult = rightTask.join();\n            sum = leftResult + rightResult;\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        CountTask task = new CountTask(0, 100);\n        Future<Integer> result = forkJoinPool.submit(task);\n        try{\n            System.out.println(\"result: \" + result.get());\n        } catch(InterruptedException | ExecutionException e){\n            System.out.println(e.toString());\n        }\n    }\n}\n```\n\n    - #### task在执行过程中可能会出现异常，这个异常我们在主线程中是不可能捕获到的，因此ForkJoinTask提供了isComputeAbnormally()方法来发现异常，通过getException()方法来获取异常\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"Java中的并发工具类","url":"/2018/12/05/java-concurrent-util/","content":"\nJDK并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了并发流程控制手段，Exchanger工具类则提供了线程间交换数据的一种手段。\n\n- ### 等待多线程完成COuntDownLatch\n```java\nimport java.util.concurrent.*;\n\npublic class CountDownLatchDemo {\n    static CountDownLatch c = new CountDownLatch(2);\n    public static void main(String[] args) throws Exception{\n        new Thread(new Runnable(){\n            @Override\n            public void run(){\n                System.out.println(1);\n                c.countDown();\n                System.out.println(2);\n                c.countDown();\n            }\n        }).start();\n        c.await();\n        System.out.println(3);\n    }\n}\n```\n\n- ### 同步屏障CyclicBarrier\nCyclicBarrier字面意思是可循环使用（Cyclic）的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障是被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有线程继续运行。\n```java\nimport java.util.concurrent.*;\n\npublic class CyclicBarrierDemo {\n    static CyclicBarrier c = new CyclicBarrier(2);\n    public static void main(String[] args){\n        new Thread(new Runnable(){\n            @Override\n            public void run(){\n                try{\n                    long count = 1000000000L;\n                    while(count-- > 0);\n                    c.await();\n                }catch(Exception e){\n                    System.out.println(e.toString());\n                }\n                System.out.println(1);\n            }\n        }).start();\n        try{\n            c.await();\n        }catch(Exception e){\n            System.out.println(e.toString());\n        }\n        System.out.println(2);\n    }\n}\n```\n\nCyclicBarrier提供了一个更高级的构造函数```CyclicBarrier(int parties, Runnable barrierAction)```，用于在线程到达屏障时，优先执行barrierAction。\n\n- ### 控制并发线程数量的Semaphore\n信号量（Semaphore）是用来控制同事访问待定资源的线程适量，它通过协调各个线程，以保证合理使用公共资源。\n\n应用场景：  \nSemaphore可以用来做流量控制，特别是公共资源有限的场景，比如数据库连接。假如有一个需求，尧都区几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这时必须要控制只有10个线程同时获取到数据库连接保存数据。这是使用Semaphore来做流量控制。\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"使用AQS构建的独占锁","url":"/2018/12/04/AQS-Mutex-demo/","content":"\n独占锁的自定义同步组件：\n```java\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.TimeUnit;\nimport java.lang.InterruptedException;\nimport java.util.Random;\n\nclass Mutex implements Lock {\n    private static class Sync extends AbstractQueuedSynchronizer{\n        protected boolean isHeldExclusively(){\n            return getState() == 1;\n        }\n        public boolean tryAcquire(int acquires){\n            if(compareAndSetState(0, 1)){\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n        protected boolean tryRelease(int releases){\n            if(getState() == 0) throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n        Condition newCondition(){\n            return new ConditionObject();\n        }\n    }\n    private final Sync sync = new Sync();\n    public void lock(){\n        sync.acquire(1);\n    }\n    public boolean tryLock(){\n        return sync.tryAcquire(1);\n    }\n    public void unlock(){\n        sync.release(1);\n    }\n    public Condition newCondition(){\n        return sync.newCondition();\n    }\n    public boolean isLocked(){\n        return sync.isHeldExclusively();\n    }\n    public boolean hasQueuedThread(){\n        return sync.hasQueuedThreads();\n    }\n    public void lockInterruptibly() throws InterruptedException{\n        sync.acquireInterruptibly(1);\n    }\n    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException{\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n    public static void main(String[] args) throws Exception{\n        final Mutex lockDemo = new Mutex();\n        class ThreadDemo extends Thread{\n            public void run(){\n                System.out.println(Thread.currentThread().getName() + \": waiting\");\n                lockDemo.lock();\n                System.out.println(Thread.currentThread().getName() + \": running\");\n                long count = new Random().nextInt(1000000000) + 1000000000;\n                while(count-- > 0);\n                System.out.println(Thread.currentThread().getName() + \": end\");\n                lockDemo.unlock();\n            }\n        }\n        for(int i = 0; i < 10; i++){\n            ThreadDemo thread = new ThreadDemo();\n            thread.setName(\"thread \" + i);\n            thread.start();\n        }\n    }\n}\n```\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"使用AQS构建的共享锁","url":"/2018/12/04/AQS-TwinsLock-demo/","content":"\n共享锁的自定义同步组件：\n```java\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.TimeUnit;\nimport java.lang.InterruptedException;\nimport java.lang.Thread;\nimport java.util.Random;\n\nclass TwinsLock implements Lock {\n    private static class Sync extends AbstractQueuedSynchronizer{\n        Sync(int count){\n            if(count <= 0){\n                throw new IllegalArgumentException(\"count must large than zero\");\n            }\n            setState(count);\n        }\n        public int tryAcquireShared(int reduceCount){\n            for(;;){\n                int current = getState();\n                int newCount = current - reduceCount;\n                if(newCount < 0 || compareAndSetState(current, newCount)){\n                    return newCount;\n                }\n            }\n        }\n        public boolean tryReleaseShared(int returnCount){\n            for(;;){\n                int current = getState();\n                int newCount = current + returnCount;\n                if(compareAndSetState(current, newCount)){\n                    return true;\n                }\n            }\n        }\n        protected boolean isHeldExclusively(){\n            return getState() == 1;\n        }\n        public boolean tryAcquire(int acquires){\n            if(compareAndSetState(0, 1)){\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n        protected boolean tryRelease(int releases){\n            if(getState() == 0) throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n        Condition newCondition(){\n            return new ConditionObject();\n        }\n    }\n    private final Sync sync = new Sync(2);\n    public void lock(){\n        sync.acquireShared(1);\n    }\n    public boolean tryLock(){\n        return sync.tryAcquire(1);\n    }\n    public void unlock(){\n        sync.releaseShared(1);\n    }\n    public Condition newCondition(){\n        return sync.newCondition();\n    }\n    public boolean isLocked(){\n        return sync.isHeldExclusively();\n    }\n    public boolean hasQueuedThread(){\n        return sync.hasQueuedThreads();\n    }\n    public void lockInterruptibly() throws InterruptedException{\n        sync.acquireInterruptibly(1);\n    }\n    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException{\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n    public static void main(String[] args) throws Exception{\n        final TwinsLock lockDemo = new TwinsLock();\n        class ThreadDemo extends Thread{\n            public void run(){\n                System.out.println(Thread.currentThread().getName() + \": waiting\");\n                lockDemo.lock();\n                System.out.println(Thread.currentThread().getName() + \": running\");\n                long count = new Random().nextInt(1000000000) + 1000000000;\n                while(count-- > 0);\n                System.out.println(Thread.currentThread().getName() + \": end\");\n                lockDemo.unlock();\n            }\n        }\n        for(int i = 0; i < 10; i++){\n            ThreadDemo thread = new ThreadDemo();\n            thread.setName(\"thread \" + i);\n            thread.start();\n        }\n    }\n}\n```\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"git config配置","url":"/2018/12/04/git-config/","content":"\n#####  git config有下列四个级别\n\n| 级别| 解释|\n| :-: | :- |\n| ```--system``` | 系统级 |\n| ```--global``` | 全局级 |\n| ```--local``` | 本地仓库级 |\n| ```--file <filename>``` | 本文件级 |\n\n##### - 别名配置\n```\ngit config --global alias.st status\ngit config --global alias.br branch\ngit config --global alias.ci commit\n收藏网友的丧心病狂的log\ngit config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\"\n```\n\n##### - 查看配置列表\n```\ngit config --global --list\n```\n\n#### git rm\n\n##### - 删除已经提交了的文件\n```\ngit rm -r --cached node_modules/\ngit add -A \ngit ci -m 'remove node_modules'\ngit push\n```\n","tags":["备忘录"],"categories":["Linux","Git"]},{"title":"AQS介绍","url":"/2018/12/03/AQS/","content":"\n- ### 队列同步器\n队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。\n同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法类管理同步状态，在抽象方法实现过程中免不了要对同步状态进行更改，这还少就需要使用同步器中提供的3个方法(getState()、setState(int newState）、compareAndSetState(int except, int update))来进行操作，因为他们能够保证状态的改变是安全的。自雷推荐被定义为自定义同步组件的静态内部类，同步器吱声没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持度独占式的获取同步状态，也可以支持共享式的获取，这样就可以实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。  \n同步器是实现锁的关键，在锁的实现中聚合了同步器，利用同步器实现锁的语义，可以这样理解：锁是面向使用者的，他定义了使用者与锁的交互接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所关注的领域。  \n1. 队列同步器的接口与示例\n同步器的设计师基于模板方法模式的，也就是说使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义的同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。\n\n重写同步器指定方法时，需要使用同步器提供如下方法。  \n    1. getState()：获取当前同步状态\n    2. setState(int newState)：设置当前同步器状态\n    3. compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证设置的原子性\n    \n    同步器可重写的方法与描述：\n   \n|方法名称|描述|\n|:--- |:---|\n|protected boolean tryAcquire(int arg)|独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后在进行CAS设置同步状态|\n|protected boolean tryRelease(int arg)|独占式释放同步状态，等待同步状态的线程将有机会获取同步状态|\n|protected int tryAcquireShared(int arg)|共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败|\n|protected int tryReleaseShared(int arg)|共享式释放同步状态|\n|protected boolean isHeldExclusively()|当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程占用|\n\n同步器提供的模板方法基本上分为3类：独占式的获取与释放同步状态、共享式的获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将会使用同步器提供的模板方法来实现自己的同步语义。\n\n\n> 这里实现的同步组件只允许一个线程占有锁，Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式后驱和释放同步状态。在tryAcquire(int acquires)中，如果经过CAS设置成功（同步状态设置为1），则代表获取了同步状态，而在tryRelease(int releases)方法中只是将同步状态设置为0。用户使用Mutex时不会直接和内部同步器的实现大脚到，而是直接调用Mutex中提供的方法。\n\n- #### 队列同步器实现分析\n这里重点分析同步器是如何完成线程同步的，主要包括：同步队列、苏展示同步状态的获取与释放、共享式同步状态获取与释放以及超市获取同步状态等同步器的核心数据结构与模板方法。  \n\n1. ##### 同步队列\n同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器将会对当前线程以及等待状态等信息构成一个节点并将其加入同步队列，同时将会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，时期再次尝试获取同步状态。  \n同步队列中的节点Node用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型及名称以及描述如下：  \n\n|属性类型以及名称|描述|\n|:---|:---|\n|int waitStatus| 等待状态，包含以下状态：  |\n|  |1. CANCELLED，值为1，由于在永不队列中等待的线程鞥带超时或者被中断，需要从同步队列中取消等待，节点进入该状态将不会变化|\n|  |2. SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继结点，是后继节点的线程继续运行|\n|  |3. CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中|\n|  |4. PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件的传播下去|\n|  |4. INITIAL，值为0，初始状态|\n|Node prev|前驱节点，当节点加入同步队列时被设置（尾部添加）|\n|Node next|后继节点|\n|Node nextWaiter|等待队列中的后继节点。如果当前节点是共享的，那么这个字段将是一个常量，也就是说节点类型（独占或共享）和等待队列中的后继节点共用同一个字段|\n|Thread thread|获取同步状态的线程|\n\n> 节点是构成同步队列的基础，同步器将拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入到同步队列的尾部。\n>> - 同步器提供了一个机遇CAS的设置尾节点的方法：compareAndSetTail(Node expect, Node update)，它需要传递当前线程\"认为\"的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。  \n>> - 同步队列遵守FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。PS：首节点的设置是通过获取同步状态成功的线程设置的，因此线程安全。  \n\n2. ##### 独占式同步状态的获取与释放\n通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进图同步队列中，后继对线程进行中断操作时，线程不会从同步队列中移除。\n- 同步器的acquire方法（同步状态的获取）：\n```java\npublic final void acquire(int arg) {\n    if(!tryAcquire(arg) && \n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n> - 这里先使用!tryAcquire尝试获取同步状态，失败后加入同步队列中\n> - 构造同步节点（独占式：Node.EXCLUSIVE）并通过addWaiter加入到同步队列尾部，最后调用acquireQueued(Node node, int arg)方法，该节点以死循环的方式获取同步状态。如果获取不到阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或者阻塞线程被中断来实现。\n下面是构建Node以及添加入同步队列的实现：\n```java\nprivate Node addWaiter(Node mode){\n    Node node = new Node(Thread.currentThread(), mode); //这里构建节点，并使用参数的模式\n    Node pred = tail; // 获取尾节点\n    if(pred != null){ // 这里尝试了快速在尾部添加节点\n        node.prev = pred;\n        if(compareAndSetTail(pred, node)){\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node); // 这里同步器使用死循环来保证节点添加\n    return node;\n}\nprivate Node enq(final Node node){\n    for(;;){\n        Node t = tail;\n        if(t == null){ // 尾节点为空，将尾节点指向头结点\n            if(compareAndSetHead(new Node()))\n                tail = head;\n        }else{ // 将需要添加的节点的前驱节点指向tail，并将node添加到队尾\n            node.prev = t;\n            if(compareAndSetTail(t, node)){\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n> 这里enq方法将添加节点变得串行化了。（自旋）\n接下来我们看acquireQueue(final Node node, int arg)，当前线程在\"死循环\"中尝试获取同步状态，只有同步队列头结点才能尝试获取同步状态：\n1. 头结点是成功获取到同步状态的节点，而头结点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点被唤醒之后需要检查自己的前驱节点是否是头结点（即同步队列头）。\n2. 维护同步队列的FIFO原则，该方法中，节点自旋获取同步状态。\n\n- 同步器的release方法（同步状态的释放）：\n```java\npublic final boolean release(int arg){\n    if(tryRelease(arg)){ // 尝试释放\n        Node h = head;\n        if(h != null && h.waitStatus != 0) \n            unparkSuccessor(h); // 这里使用LockSupport来唤醒处于等待状态的线程\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n3. ##### 共享式同步状态的获取与释放\n共享式获取与独占式获取主要的区别在于同一时间能否有多个线程同时获取到同步状态。以为内件的读写为例，如果一个程序正在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。\n获取同步状态代码如下\n```java\npublic final void acquireShared(int arg){\n    if(tryAcquireShared(arg) < 0){ // 1\n        doAcquireShared(arg);\n    }\n}\nprivate void doAcquireShared(int arg){\n    final Node node = addWaiter(Node.SHARED); // 2\n    boolean failed = true;\n    try{\n        boolean interrupted = false;\n        for(;;){ // 3\n            final Node p = node.predecessor();\n            if(p == head){\n                int r = tryAcquireShared(arg);\n                if(r >= 0){\n                    setHeadAndPropagate(node, r);\n                    p.next = null;\n                    if(interrupted){\n                        selfInterrupt();\n                    }\n                    failed = false;\n                    return;\n                }\n            }\n            if(shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    }finally{\n        if(failed)\n            cancelAcquire(node);\n    }\n}\n```\n> 1: 同步器先尝试调用tryAcquireShared(int arg)方法尝试获取同步状态，返回值大于等于0时成功获取状态。因此，在共享式获取的自旋过程中，成功获取到的同步状态并退出自旋的田间就是tryAcquireShared(int arg)返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中吐过当前节点的前去为头结点是，尝试获取去同步状态，如果返回值大于等于0，表示盖茨获取同步状态成功并从自旋过程中退出。  \n与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态，\n```java\npublic final boolean releaseShared（int arg）{\n    if(tryReleaseShared(arg)){\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n> 该方法在释放同步状态后，将会唤醒后续处于等待状态的节点。对于呢能够支持多个线程同时访问的并发组件，他和独占式的主要区别在于tryReleaseShared(int arg)方法必须确保同步状态线程安全释放，一般是通过循环和CAS来保证的。因为释放同步状态的操作会同时来自多个线程。\n\n4. ##### 独占式超时获取同步状态\n通过调用同步器的doAcquireNanos(int arg, long nanosTimeout)方法可以超时获取同步状态，记载指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false。该方法提供传统java同步操作所不具备的特性。\n> 背景知识：  \n> 响应中断的同步状态获取的过程。在java5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的终端标志位会被修改，但是线程依旧会阻塞在synchronized上，等待获取锁。在java5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。  \n\n超时后去同步状态过程可以视作响应中断获取同步状态的加强版，doAcquireNanos(int arg, long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性，针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeous的计算公式为：nanosTimeout -= now - lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，反之表示已经超时。\n```java\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException{\n    long lastTime = System.nanoTime();\n    final Node node = addWaiter(node.EXCLUSIVE);\n    boolean failed = true;\n    try{\n        for(;;){\n            final Node p = node.predecessor();\n            if(p == head && tryAcquire(arg)){\n                setHead(node);\n                p.next = null;\n                failed = false;\n                return true;\n            }\n            if(nanosTimeout <= 0)\n                return false;\n            if(shouldParkAfterFailedAcquire(p, node)\n                && nanosTimeout > spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            long now = System.nanoTime();\n            nanoTimeout -= now - lastTime;\n            lastTime = now;\n            if(Thread.interrupted()){\n                throw new InterruptException();\n            }\n        }\n    }finally{\n        if(failed)\n            return false;\n    }\n}\n```\n\n> 该方法自旋的时候会重新计算超时时间\n\n- ### 示例：自定义同步组件-- TwinsLock\n这里设计一个同步工具：该工具在同一时刻，只允许之多两个线程同时访问，超过两个线程访问江北阻塞，我们将其称之为TwinsLock。\n1. 首先，确定访问模式，TwinsLock能够在同一时刻允许多个线程访问，显然是共享式访问，因此，需要使用同步器提供的acquireShared(int arg)和Shared相关方法，这就必须要重写tryAcquireShared(int arg)和tryReleaseShared(int arg)方法。\n2. 其次，定义资源数。TwinsLock在同一时刻之多允许两个线程同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取后status减1，该线程释放，则加1。合法的status状态范围为0、1、2。使用compareAndSet(int expect, int arg)做原子保障。\n3. 最后，组合同步器完成功能。\n\n\n5. ### 可重入锁\n可重入锁的主要在获取锁的时候添加了是否是当前线程的判断，并且把重入的次数写入，在释放锁的时候钱N-1次释放不重置当前线程，最后一次将当前线程置null，并且设置state。\n> 可重入锁中分为公平锁和非公平锁两种，其中公平锁保证了线程不饥饿，但是会增加上下文切换。非公平锁不保证线程饥饿，但是因为其极少的线程切换，保证了更大的吞吐量。\n\n6. ### 读写锁\n之前提到的锁基本上都是拍他锁，这些锁在同一时刻只允许一个线程访问，而读写锁允许多个读线程，但是在写线程访问时只允许一个写线程，其他线程不管读写军备阻塞。通过读写锁是的并发性有了很大提升。  \n> 读写锁内部使用一个32位的变量，将其拆分为高低两个16位，高16位表示读状态，低16位表示写状态，内部使用位运算判断同步状态。  \n\n7. ### LockSupport工具\nLockSupport定义了一组已park开头的方法用来阻塞当前线程，以及unpark(Thread thread)的方法用来唤醒线程。\n\n| 方法名称                      | 描述                                                                      |\n| :---                          | :---                                                                      |\n| void park()                   | 阻塞当前线程，如果调用unpark(Thread thread)方法或者当前线程被中断才能返回 |\n| void parkNanos(long nanos)    | 阻塞当前线程直到超时                                                      |\n| void parkUntil(long deadline) | 阻塞当前线程，直到deadline(form UTC)                                      |\n| void unpark(Thread thread)    | 唤醒处于阻塞状态的thread                                                  |\n\n8. ### Condition接口\n任意一个java对象都拥有一组监视器方法（在java.lang.Object上），主要包括（wait()、wait(long timeout)、notify()、notifyAll()）方法，这些方法与synchronized配合，可以实现等待/通知模式，但是两个使用方法和功能还是有差别的。\n通过对比Object的监视器方法和Condition接口，可以更详细的了解Condition特性:\n\n| 对比项                                               | Object Monitor Methods | Condition                                                       |\n| :---                                                 | :---                   | :---                                                            |\n| 前置条件                                             | 获取对象的锁           | 调用Lock.lock()获取锁，调用Lock.newCondition()获取Condition对象 |\n| 调用方式                                             | 直接调用               | 直接调用                                                        |\n| 等待队列个数                                         | 一个                   | 多个                                                            |\n| 当前线程释放锁并进入等待状态                         | 支持                   | 支持                                                            |\n| 当前线程释放锁并进入等待状态，在等待状态不能响应中断 | 不支持                 | 支持                                                            |\n| 当前线程释放锁并进入超时等待状态                     | 支持                   | 支持                                                            |\n| 当前线程释放锁并进图等待状态到将来某个时间           | 不支持                 | 支持                                                            |\n| 唤醒等待队列的一个线程                               | 支持                   | 支持                                                            |\n| 唤醒等待队列中的全部线程                             | 支持                   | 支持                                                            |\n\n1. 示例\nCondition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前将获取到的Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法创建，换句话说Condition对象依赖于Lock对象的。  \n```java\nLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\npublic void conditionWait() throws InterruptedException{\n    lock.lock();\n    try{\n        condition.await(); // 1\n    }finally{\n        lock.unlock();\n    }\n}\npublic void conditionSignal() throws InterruptedException{\n    lock.lock();\n    try{\n        condition.signal(); // 2\n    }finally{\n        lock.unlock();\n    }\n}\n```\n> 线程运行到1处是会释放自己已经得到的锁，在其他线程运行到2处时，当前线程才会从await()返回，并且返回前已经获取了锁。\n\nCondition实现队列的添加和删除\n```java\npublic class BoundedQueue<T>{\n    private Object[] items;\n    private addIndex, removeIndex, count;\n    private Lock lock = new ReentrantLock();\n    private Condition notEmpty = lock.newCondition();\n    private Condition notFull = lock.newCondition();\n    public Bounded(int size){\n        items = new Object[size];\n    }\n    public void add(T t) throws InterruptedException{\n        lock.lock();\n        try{\n            while(count == items.length)\n                notFull.await();\n            items[addIndex] = t;\n            if(++addIndex == items.length)\n                addIndex = 0;\n            ++count;\n            notEmpty.singal();\n        }finally{\n            lock.unlock();\n        }\n    }\n    public T remove() throws InterruptedException{\n        lock.lock();\n        try{\n            while(count == 0)\n                notEmpty.singal();\n            Object object = items[removeIndex];\n            if(++removeIndex == items.length)\n                removeIndex = 0;\n            --count;\n            notFull.await();\n            return (T) object;\n        }finally{\n            lock.unlock();\n        }\n    }\n}\n```\n\n> 该队列遵循FIFO，使用count变量表示队列实际长度，当count等于数组长时等待notFull的通知，当count等于0时等待数组不为空的通知。使用removeIndex和addIndex可以实现循环添加。\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java并发编程实例","url":"/2018/12/03/concurrent-demo/","content":"\n### 背景知识\n> java从诞生开始就内置对多线程的支持，线程作为操作系统调度的最小单元，多个线程能同时执行，这将显著提升程序性能，在多核环境中表现的更加明显。\n>> 现代操作系统在运行一个程序是，会为其创建一个进程。现代操作系统调度的最小单元是线程，也叫轻量级进程，字啊一个进程里可以创建多个线程，这些线程都拥有各自的计数器、对战和局部变量的那个属性，并且能够访问共享内存变量。处理器在说这些线程上高速切换，让使用者感觉这些线程在同时执行。\n\n```java\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadInfo;\nimport java.lang.management.ThreadMXBean;\n\npublic class scratch_1 {\n    public static void main(String[] args) {\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        for (ThreadInfo threadInfo : threadInfos) {\n            System.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\n        }\n    }\n}\n```\n> 运行结果：\n> ```\n> [5] Monitor Ctrl-Break\n> [4] Signal Dispatcher\n> [3] Finalizer\n> [2] Reference Handler\n> [1] main\n> ```\n\n- ### 线程的优先级\n现代操作系统基本采用时分的形式调度运行的进程，操作系统会分出一个个时间片，线程会分配若干时间片，当线程的时间片用完了就会发生线程调度，并等待下次分配。线程分配到时间片多少也决定了线程使用处理器资源的多少，儿线程的优先级决定线程需要多或者少扥配一些处理器资源的线程属性。\n\n在java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在新汉城构建的时候通过setProority(int)方法来修改优先级，默认优先级是5，优先级搞得线程分配的时间片的数量要多于优先级地的线程。设置线程优先级是，针对频繁阻塞的线程需要设计较高的优先级，儿片中计算的线程设计交底的优先级，确保处理器不会被独占，在不同的JVM及操作系统上，线程规划会存在差异，有些操作西永甚至会忽略线程优先级的设定。\n\n- ### 线程的状态  \n\n| 状态名称 | 说明 |\n| :---: | :---: |\n|NEW | 初始状态：线程已经被构建，但是还没有调用start()方法|\n|RUNNABLE|运行状态，java线程将操作系统中的就绪和运行两种状态笼统的称作为\"运行中\"|\n|BLOCKED|阻塞状态，表示线程阻塞于锁|\n|WAITING|等待状态，表示线程进入等待状态，进图该状态表示当前线程需要等待其他线程做出一些特定操作（通知或者中断）|\n|TIME_WAITING|超时等待状态，该状态不同于WAITING，他是可以在指定时间自行返回的|\n|TERMINATED|种植状态，表示当前线程已经执行完毕|\n\n\n- ### Daemon线程\nDaemon线程是一种支持性线程，因为它主要被用于程序中后台调度以及支持性工作，这意味着，当一个java虚拟机中不存在飞Daemon线程的时候，java虚拟机将会退出，使用```Thread.setDaemon(true)```将线程设置为Daemon线程。\n> Daemon属性需要在启动线程之前设置，不能再启动线程之后设置。\n>> 在购将Daemon线程时，不能依靠finally块中的内容来确保执行关闭或者清理资源。\n\n- ### 线程的启动和终止\n使用```start()```来启动，随着```run()```执行完毕也随之终止。\n\n- #### 线程的启动\n在调用```start()```方法之后，只要java虚拟机认为：线程规划器空闲，就会立刻启动start()\n\n- #### 理解中断\n中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。\n\n线程通过检查自身是否被中断来进行相应，线程通过方法```isInterrupted()```来进行判断是够被中断，也可以调用静态方法```Thread.interrupt()```对当前线程的中断表示进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在电泳该线程对象的```isInterrupted()```时依旧会返回false。\n\njava API中有很多声明抛出InterruptedException的方法。这些方法在抛出INterruptedException之前，java虚拟机会先将该线程中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法会返回false。\n\n- #### 安全的终止线程\n通过```thread.interrupt()```和```thread.cancel()```方法均可以。通过标识位或者中断操作的方法能够使线程在终止时后机会去清理资源。\n\n- ### 线线程间通信\n    1. synchronized  \n    使用了monitorenter和monitorexit指令来实现，monitorenter失败的线程会进入SynchronizedQueue队列进行等待。\n    2. 等待/通知机制  \n    使用生产者/消费者模式，等待通知机制是内置在Object对象上的。  \n    \n    |方法名称|描述|\n    | :---: | :---: |\n    |notify()| 通知一个在对象上等待的线程，使其wait()方法返回，前提是改线程获取到了锁|\n    |notifyAll()|通知所有等待在该对象上的线程|\n    |wait()| 调用该方法进图WAITTING状态，只有等待另外线程的通知或者被中断才会返回，调用该方法后释放锁|\n    |wait(long)| 超时等待，没有在规定时间内得到通知就返回|\n    |wait(long, int)|对超时时间更加精细，可以达到纳秒|\n    \n    3. 管道输入/输出流  \n    管道输入输出流和普通文件输入输出流或者网络输入输出流不同的是，它主要用于线程之间的数据传输，而传输的媒介是内存。\n    管道输入输出流包含了下面四种实现：PipiedOuputStream、PipedInputStream、PipedReader、PipedWriter，前两种面向字节，后两种面向字符。\n    \n    4. Thread.join()的使用  \n    使用thread.join()可以等待调用该方法线程结束再执行后面代码。\n    \n    5. ThreadLocal的使用  \n    ThreadLocal，即线程变量，是一个以ThreadLocal对象未见、任意对象为值得存储结构。这个结构被附带在线程上，也就是一个线程可以根据一个ThreadLocal对象查询到值。  \n    ```java\n    class Scratch {\n        private static final ThreadLocal<Long> TIME_THREADLOCAL = new ThreadLocal<>();\n\n        public static final void begin() {\n            TIME_THREADLOCAL.set(System.currentTimeMillis());\n        }\n\n        public static final long end() {\n            return System.currentTimeMillis() - TIME_THREADLOCAL.get();\n        }\n\n        public static void main(String[] args) {\n            Scratch scratch = new Scratch();\n            scratch.begin();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"cost time: \" + scratch.end());\n        }\n    }\n    ```\n    > ```java cost time: 1001 ```\n    \n- ### 等待超时模式  \n这里的伪代码是：\n```java\npublic synchronized Object get(long mills) throws InterruptedException { // mills 作为超时等待时间\n    long future = System.currentTimeMillis() + mills; // 计算最终的返回时间\n    long remaining = mills; \n    while((result == null) && remaining > 0){\n        wait(remaining); // 这里使用Object.wait(long)进行等待，如果超过等待时间，再去对比future，超出则返回默认值。\n        remaining = future - System.currentTimeMillis();\n    }\n    retrun result;\n}\n```\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java中的锁","url":"/2018/12/03/lock/","content":"\n- ### Lock接口\n锁是由来控制多个线程访问共享资源的方式，一般来书哦，一个锁能够防止多个线程同时访问共享资源，在Lock接口出现之前，java程序是依靠synchronized关键字实现锁功能的，儿java5之后，并发包中新增了Lock接口用来实现锁功能。它提供了与synchronized关键字类似的同步功能，知识在使用时需要显示的获取和释放锁。虽然他缺少了饮食获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断性的说去锁以及超时锁获取等多种synchronized关键字多不具备的同步特性。  \n使用synchronized关键字将会饮食的获取锁，但是他讲锁的获取和释放固话了。  \nLock接口提供的synchronized关键字所不具备的主要特性：  \n\n| 特性| 描述|\n| :--- | :--- |\n|尝试非阻塞的获取锁|当前线程尝试获取锁，如果这一时刻没有被其他线程获取到，则成功获取并持有锁|\n|能被中断的获取锁|与synchronized不同，获取到所得线程能够响应中断，当前获取到锁的想爱你城被中断时，中断异常将会被抛出，同时释放锁|\n|超时获取锁|在制定上街区时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回|\n\n\nLock接口API：  \n\n| 方法名称|描述|\n|:---|:---|\n|void lock() |获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回|\n|void lockInterruptibly() throws InterruptException|可中断的后驱锁，和lock()方法的不同之处在于该方法会响应中断，即在所的获取中可以中断该线程|\n|void tryLock()|肠坏死非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，不能则false|\n|void tryLock(long time, TimeUnit unit) throws InterruptException|超时获取锁，下面三种情况会返回：  1. 当地安县城在超时间内获得了锁。2. 当前线程城在超时间内被中断。3. 超时时间结束，返回false|\n|void unlock()|释放锁|\n|Condition newCondition()|获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能地阿偶用该组件的wait()方法，而调用后，当前线程将释放锁|\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java并发编程艺术","url":"/2018/12/01/java-concurrency-info/","content":"\n- #### 并发不一定比同步程序快\n> 1. 线程创建需要时间\n> \n> 2. 上下文切换需要时间\n\n- #### 如何减少上线文切换\n> - 无锁并发编程：使用hash算法将数据分段给不同线程处理，保证每次同一ID数据都由同一个线程处理。\n> \n> - CAS算法：java的Atomic包中提供了CAS算法。\n> \n> - 使用最少线程：减少不必要的线程创建和切换开销\n> \n> - 协程：在一个线程中实现多任务调度，并在其他线程中维持多个任务间的切换。\n>\n\n- #### 资源限制的挑战\n    - 在某些情况下，受限于软硬件资源的限制，我们采取不同的处理方式：\n    1. 硬件限制：考虑使用集群来处理\n    2. 软件限制：考虑资源复用，如数据库连接、socket等。\n    - 在资源受限的条件下进行并发：核心思想就是根据不同的类型调整并发数。\n\n##### 相关工具\n\n- `ps -ef|grep Scratch ` 找到pid\n- `jstack 1498` 打印完整内存信息\n\n![deadLock-1.webp](/assets/img/deadLock-1.webp)\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"java内存模型","url":"/2018/12/01/java-memory-model/","content":"\n- ### 并发编程中的两个关键问题：\n> - 线程之间如何通信\n> - 线程之间如何同步\n>> - 同步是指程序中用于控制不同线程间操作发生的相对顺序的机制.在共享内存的并发模型里同步时显示进行的.在消息传递的并发模型里，由于消息的发送必须在消息接受之前，因此同步时隐式进行的\n>> - 在共享内存的并发模型里，线程之间的共享程序的公共状态，通过读写内存中的公共状态进行隐式通信\n>> - 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显示进行通信\n>>> java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个通信工作机制，很可能会遇到各种奇怪的内存可见性问题.\n\n- ### java内存模型的抽象结构\n在java中，所有的实例域，静态域和数组元素都存在堆内存中，福内存在线程之间共享，局部变量，方法定义参数和异常处理器参数不会再线程之间共享，他们不会有内存可见性问题，也不瘦内存模型的影响.\nJava线程时间通信有java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入合适对李宁一个线程可见，从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存中，每个咸亨都有一个私有的本地内存，本地内存中存储了该线程已读/写共享变量的副本.本地本村是JMM的一个抽象概念，并不真实存在.它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化.\n- ### 从源代码到指令序列的重排序\n在执行程序是，为了提高性能，编译器和处理器常常会对指令做重排序，重排序分3种类型\n> 1. 编译器优化的重排序（编译器重排序）.编译器在不改变单线程程序予以的前提下，可以重新安排语句的执行顺序.\n> 2. 指令集并行的重排序（处理器重排序）.现代处理器采用了指令集并行技术（ILP）来讲多条指令重叠执行.如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n> 3。内存系统的重排序（处理器重排序）。由于处理器使用缓存和读/写韩冲去，是的加载和存储操作看上去是在乱序执行。\n>> ```源代码->编译器后话重排序->指令级并行重排序->内存系统重排序->最终执行的指令序列```\n>>> - 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的）\n>>> - 对于处理器重排序，JMM的处理器重排序规则会要求java 编译器生成指令序列是，插入特定类型的内存屏障，通过内存屏障指令来禁止特定类型的处理器重排序。\n\n- ### 并发编程模型的分类\n现代处理器使用写缓冲区临时保存箱内存写入的数据。写缓冲区可以保证指令流水线吃血运次那个，他可以避免由于处理器停顿下来等待想内存写入数据而产生的延迟。同事通过以批处理的方式刷鞋缓冲区，以及合并写缓冲区中对于同一内存地址的多次写，减少对内存中线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对他所在的处理器课件。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读写操作的顺序执行不一定与内存实际发生的读写顺序一致。\n- ### happens-before简洁\n从JDK5开始，java使用心得JSR-133内存模型，JSR-133 使用happens-before的概念来阐述操作之间的内存可见性。\n在JMM中如果一个操作执行额结果需要对另一个操作课件，那么这两个操作之间必须要存在happens-before关系。\n> 常用的happens-before规则\n> - 程序顺序规则：一个线程中的每个操作，happens-before于该线程的任意后续操作\n> - 监视器锁规则：对一个锁的解锁，happens-before于虽有对这个锁的加锁。\n> - volatile变量规则：对一个volatile域的写happens-before域任意后续对这个volatile域的读\n> - 传递性：如果A happens-before，切Bhappens-before C，那么A happens-before C。\n>> 两个操作之间的happens-before关系，并不意味着掐一个操作必须要在后一个操作之前执行!happens-before仅仅要求前一个操作对后一个操作课件，切前一个操作按顺序排在第二个操作之前。\n","tags":["学习笔记"],"categories":["Java","VirtualMachine"]},{"title":"锁","url":"/2018/12/01/reentrant-lock/","content":"\n锁的获取和释放和volatile是一致的。\n\n- ### 锁内存语义的实现\n```java\nclass ReentrantLockExample {\n    int a = 0;\n    ReentrantLock lock = new ReentrantLock();\n    public void writer(){\n        lock.lock();\n        try{\n            a++;\n        }finally{\n            lock.unlock();\n        }\n    }\n    public void reader(){\n        lock.lock();\n        try{\n            int i = a;\n        }finally{\n            lock.unlock();\n        }\n    }\n}\n```\n> 在这里的代码中，使用```lock()```和```unlock()```方法来实现获取锁和释放锁。\n> ```ReentrantLock```的实现依赖于java同步框架AbstractQueuedSynchronizer（AQS)。AQS中使用了一个整型的volatile变量（state）来维护同步状态。\n","tags":["学习笔记"],"categories":["Java","Concurrent"]},{"title":"volatile","url":"/2018/12/01/volatile/","content":"\n重排序是指编译器和处理器为了优化程序性能二队指令序列进行重新排序的一种手段。\n\n- ### 数据依赖性\n如果两个操作访问同一个变量，且两个操作中的一个为写操作。此时就存在数据依赖性。（读写顺序会影响结果）\n- #### as-if-serial语义\n不管怎么重排序编译器、runtime和处理器都必须遵守as-if-serial语义。这个特性使得单线程程序看起来是按顺序执行的。\n在happens-before规则中，JMM会进行拓扑排序来推导执行顺序。\n\n- 未同步程序在JMM喝顺序一致性模型中的差异\n1. 顺序一致性模型保证单线程内的操作会按照程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。\n2. 顺序一致性模型保证所有线程智能看到一只的操作执行顺序，而JMM不保证所有线程能看到一只的操作顺序。\n3. JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读、写都具有原子性。\n> 第三个差异与处理器总显得工作机制密切相关。在计算机中，数据通过总现在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一些列步骤称之为总线事务。总显示无包括读事务和写事务。读事务从内存传递数据到处理器，写事务从处理器出啊地数据到内存，每个事物会读写内存中的一个或多个物理上连续的字。这里的关键是，总线会同步视图并发使用总线的事物。在一个处理器执行总线事务期间，总线会禁止其他的处理器和设备执行内存的读写。（通过总线仲裁来对总线的竞争作出裁决，保证单个总线事务之中的读写具有原子性）。\n>> 在一些32位的处理器上，如果要求对64位的数据写操作具有原子性，会有比较大的开销。为了照顾着中处理器，java语言规范鼓励但不强求JVM对64位的变量写操作具有原子性。当JVM在这个处理器上运行时，可能会把一个64位的变量的写操作拆分为两个32位的写操作来执行，这两个写操作可能被分配到不同的总线事务中执行，此时这个写操作将不具有原子性。\n>>> 64位变量的读操作都具有原子性。\n\n- ### volatile的内存语义\n当生命共享变量为volatile后，对这个变量的读写将会特别。\n\n1. volatile的特性\n    1. 可见性：对一个volatile变量的毒，总是能看到人以县城对这个colatile变量最后的写入。\n    2. 原子性，对任意单个colatile变量的读写具有原子性，但类似于volatile++这种符合操作不具有原子性。\n一个volatile变量的单个读写操作，与一个普通变量的读写操作都是用用一个锁来同步的效果相同。\n> 锁的happens-before规则保证释放锁和获得所的两个线程之间的内存可见性，这意味着一个volatile变量的毒，总能考到人以县城对这个volaile变量最后的写入。\n\n2. 从JSR-133 开始，volatile变量的亵渎可以实现线程之间的通信。\n从内存语义的角度来说，volatile的读写与锁的释放获取具有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile毒与锁的获取有相同的内存语义。\n\n3. volatile写-读的内存语义\n线程在写volatile变量后，会同步到主内存中，\n线程在读volatile变量时，JMM会把该新城对应的本地内设置为无效，并从主内存中读取。\n> 总结：\n> 1. 线程A写一个volatile变量，是指山是线程A项接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。\n> 2. 线程B读一个volatile变量，是指上是线程B接收了之前某个线程发出的消息。\n> 3. 线程A写一个volatile变量，随后线程B读取了这个变量，实质上是线程A通过主内存项线程B发送消息（volatile变量）。\n\n4. volatile重排序规则\n\n| 是否能重排序 |  | 第二个操作 |  |\n| :---: | :---: | :---: | :---: |\n| 第一个操作 | 普通 读/写 | volatile 读 | volatile 写 |\n| 普通 读/写 |   |  | NO |\n| volatile 读 | NO | NO | NO |\n| volatile 写 |   | NO | NO |\n\n> JMM采取的是一种保守内存屏障策略\n> 1. 在每个volatile写操作前面插入一个StoreStore屏障。\n> 2. 在每个volatile写操作后面插入一个StoreLoad屏障。\n> 3. 在每个volatile读操作前面插入一个LoadLoad屏障。\n> 4. 在每个volatile读操作后面插入一个LoadStore屏障。\n\n>> 锁和volatile的区别：\n>> 1. volatile仅仅保证对单个volatile变量读写具有原子性，锁对整个临界区代码的执行具有原子性。\n>> 2. 在功能上，锁比volatile更强大。\n>> 3. 在可伸缩性和执行性上，volatile比锁更强大。\n\n- ### 个人对volatile的理解\n    1. volatile只保证变量的取值、赋值是原子性的\n    2.\n","tags":["学习笔记"],"categories":["Java","VirtualMachine"]},{"title":"小程序点滴1","url":"/2018/11/15/wechat-disbale-border/","content":"\n{% raw %}\n- 去除小程序边框\n\n```\nbutton::after{\n    border: none;\n}\n```\n\n- 点击右侧图标展开盒子方案\n\n1. wxml: \n\n```\n<view wx:key='devices_{{index}}' class='device-info' wx:for='{{devices}}'>\n  <view class='device_name_id' wx:key='device_name_id_{{index}}'>\n    <text class='name' wx:key='name_{{index}}'>{{item.name}}:</text>\n    <text class='deviceId' wx:key='deviceId_{{index}}'>{{item.deviceId}}</text>\n  <button class=\"{{ !!item.showDetail ? 'toggle-btn-open' : 'toggle-btn-close' }}\" wx:key='btn_{{index}}' data-device-id='{{item.deviceId}}' bindtap='toggleDetailInfo'></button>\n  </view>\n  <view wx:if='{{!!item.showDetail}}'>\n    <view class='RSSI' wx:key='RSSI_{{index}}'>RSSI: {{item.RSSI}}</view>\n    <view class='advertisServiceUUID' wx:key='advertisServiceUUID_{{index}}'>advertisServiceUUID: {{item.advertisServiceUUID}}</view>\n    <view class='advertisData' wx:key='advertisData_{{index}}'>advertisData: {{item.advertisData}}</view>\n    <view class='localName' wx:key='localName_{{index}}'>localName: {{item.localName}}</view>\n    <view class='serviceData' wx:key='serviceData_{{index}}'>serviceData: {{item.serviceData}} </view>\n  </view>\n</view>\n```\n\n> 使用```wx:if='{!!item.showDetail}'```绑定展开开关\n>\n> 使用```class=\"{{ !!item.showDetail ? 'toggle-btn-open' : 'toggle-btn-close' }}\"```切换class\n> 使用```wx:if='{!!item.showDetail}'```绑定展开开关\n\n2. wxss: \n\n```\n.toggle-btn-close, .toggle-btn-open {\n  pointer-events: none;\n  width: 1rem;\n  height: 1rem;\n  background-color: transparent;\n}\n\n.toggle-btn-open::after, .toggle-btn-close::after {\n  border: none;\n}\n\n.toggle-btn-close::before, .toggle-btn-open::before {\n  content: '';\n  position: absolute;\n  pointer-events: auto;\n  border: 0.5rem transparent solid;\n}\n\n.toggle-btn-open::before {\n  border-left-color: red;\n  top: 0rem;\n  left: 0.6rem;\n}\n\n.toggle-btn-close::before {\n  border-top-color: green;\n  top: 0.3rem;\n  left: 0.25rem;\n}\n```\n\n> 使用在父元素上设置```pointer-events: none;```，伪类上设置```pointer-events: auto;```将父元素的点击移到伪类中\n> \n> 使用```border: 0.5rem transparent solid;```和```border-left-color: red;```设置三角形的方向和颜色\n\n3. js\n\n```\ntoggleDetailInfo: function(e) {\n  let newDevices = []\n  for (let i = 0; i < this.data.devices.length; i++) {\n    if (this.data.devices[i]['deviceId'] === e.target.dataset.deviceId) {\n      let tmp = this.data.devices[i]\n      tmp['showDetail'] = !!tmp['showDetail'] ? false : true;\n      newDevices.push(tmp)\n    } else {\n      newDevices.push(this.data.devices[i])\n    }\n  }\n  this.setData({\n    devices: newDevices\n  })\n}\n```\n\n> 在data中数组要与原来地址不一致才会触发重新渲染\n{% endraw %}\n","tags":["学习笔记"],"categories":["Develop"]},{"title":"css揭秘-第1天","url":"/2018/11/12/css-day1/","content":"\n- 如何时候半透明边框\n\n![css-day1-1.webp](/assets/img/css-day1-1.webp)\n```css\nbody {\n    background-color: #ccc;\n}\n.main {\n    border: 10px solid hsla(0, 0%, 100%, 0.5);\n    width: 100px;\n    height: 100px;\n    background-color: #f00;\n    background-clip: padding-box;\n}\n```\n- 透明边框外再加边框效果\n\n![css-day1-2.webp](/assets/img/css-day1-2.webp)\n```css\nbody {\n    background-color: #ccc;\n}\n.main {\n    border: 10px solid transparent;\n    width: 100px;\n    height: 100px;\n    background-color: #f00;\n    background-clip: padding-box;\n    box-shadow: 1px 1px 0px -1px #f00;\n}\n```\n- 方格棋盘\n\n\n![css-day1-3.webp](/assets/img/css-day1-3.webp)\n```css\nbackground-image: linear-gradient(45deg, #bbb 25%, transparent 0), \n\t\t\t\t\tlinear-gradient(45deg, transparent 75%, #bbb 0),\n\t\t\t\t\tlinear-gradient(45deg, #bbb 25%, transparent 0), \n\t\t\t\t\tlinear-gradient(45deg, transparent 75%, #bbb 0);\nbackground-size: 30px 30px;\nbackground-position: 0 0, 15px 15px, 15px 15px, 30px 30px;\n```\n> svg的实现方式\n```\nbackground: #eee url('data:image/svg+xml,\\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" fill-opacity=\".25\" >\\\n            <rect x=\"50\" width=\"50\" height=\"50\" />\\\n            <rect y=\"50\" width=\"50\" height=\"50\" />\\\n            </svg>');\nbackground-size: 100px 100px;\n```\n","tags":["学习笔记"],"categories":["CSS"]},{"title":"ssh加密问题","url":"/2018/11/12/git-ssh-cipher-not-found/","content":"\nmac升级后出现git不可用问题的解决方案,\n```\nUnable to negotiate with 183.230.198.192 port 23424: no matching cipher found. Their offer: aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se\n```\n\n- 编辑修改ssh配置，```sudo vim /etc/ssh/ssh_config```，取消这一行注释\n```\n#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc\nCiphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc\n```\n\n- 编辑.ssh/config配置, ```vim ~/.ssh/config```，添加Port、HostKeyAlgorithms\n```\nHost test\n    HostName cqkct.top\n    User jinelei\n    Port 23424\n    HostKeyAlgorithms +ssh-dss\n```\n\n","categories":["Linux","Git"]},{"title":"gitlab修改端口和域名","url":"/2018/11/12/gitlab-config/","content":"\ngitlab默认安装后配置文件在```/etc/gitlab/gitlab.rb```，gitlab内嵌的nginx配置在```/var/opt/gitlab/nginx/conf```\n\n- 修改gitlab的端口```sudo vim /etc/gitlab/gitlab.rb```\n```\nexternal_url 'http://jinelei.cn:82'\nnginx['listen_port'] = 82\n```\n\n- 修改nginx端口```sudo vim /var/opt/gitlab/nginx/conf/gitlab-http.conf```\n```\nserver {\n    listen *:82;\n    server_name jinelei.cn \n}\n```\n\n- 执行```sudo gitlab-ctl reconfigure```\n\n- 执行```sudo gitlab-ctl restart```\n","tags":["备忘录"],"categories":["Linux","Git"]},{"title":"css3伪类实现箭头","url":"/2018/11/08/css-arrow/","content":"\n话不多说，直接看代码\n\n```less\n.article-title {\n    position: relative;\n    color: rgba(0, 0, 0, .55);\n    display: inline-block;\n    text-align: left;\n    border: 1px solid #eee9dc;\n    border-radius: 8px;\n    &:before {\n        content: '';\n        position: absolute;\n        left: calc(-1em + 1px);\n        top: 0.5em;\n        border: 0.5em solid transparent;\n        border-right-color: #eee9dc;\n    }\n}\n```\n\n> 1. 在父级元素设置伪类。\n> 2. 在伪类中设置```content: '';```\n> 3. 设置边框\n> ```css\n> border: 0.5em solid transparent; \n> border-right-color: #eee9dc;\n> ```\n","tags":["学习笔记"],"categories":["CSS"]},{"title":"conkyrc配置示例","url":"/2018/11/08/conkyrc/","content":"\n我的conkyrc配置\n\n```\nbackground 1\nbackground yes\nuse_xft yes\n#xftfont WenQuandwYi Micro Hei Light:size=17\nxftfont Roboto:size=20\ntemplate1 ${font Roboto:size=20}\noverride_utf8_locale yes\nupdate_interval 1\ntotal_run_times 0\ndouble_buffer yes\nno_buffers yes\nnet_avg_samples 2\ntext_buffer_size 1024\nown_window yes\nown_window_transparent yes\nown_window_type override\nown_window_hints undecorated,below,sticky,skip_taskbar,skip_pager\ndraw_borders no\nshort_units yes\nborder_margin 1\ndefault_color 33a3dc\ndraw_shades no\n#minimum_size 1100 0\n#color\n#黄\ncolor1 FFA300\n#若绿\ncolor2 7fb80e\n#设置最大宽度\n#maximum_width  600\n#设置对齐方式:上右\nalignment tr\n#设置边距\ngap_x 35\ngap_y 35\n\n#lua_load /home/jinelei/github/script/conkyrc/conky_widgets-v1.1.lua\n#lua_draw_hook_pre widgets\n#lua_load /home/jinelei/scripts/rings-v1.2.lua\n#lua_draw_hook_pre ring_stats\n\nTEXT\n#显示时间\n${color 2a5caa}$color1${font Source Han Sans CN Normal:size=50}${time %H:%M}\n#显示秒\n${voffset -110}${color 7fb80e}${alignr}${font Source Han Sans CN Normal:pixelsize=90}${time %S}\n#显示日期星期\n${voffset -160}\n${color b2d235}${font Source Han Sans CN Normal:style=Bold:size=15}${time %b%d %a}\n#显示内核\n${voffset 20}${kernel}  ${machine}   ${sysname}\n#绘制横线\n${stippled_hr}\n#监视CPU\n$template1$color1 CPU: $color $alignr ${offset -220}${cpubar cpu}\n#${cpugraph}\n#监视硬盘\n$template1$color1 /$color$alignr ${offset -220}${fs_bar /}\n$template1$color1 /home$color$alignr ${offset -220}${fs_bar /home}\n#$template1$color1 /opt$color$alignr ${offset -220}${fs_bar /opt}\n#$template1$color1 /boot$color$alignr ${offset -220}${fs_bar /boot}\n#硬盘读写\n${voffset 8}$template1$color1 ${diskio} $alignr${voffset -8} $color ${offset -215}${diskiograph}\n#监视网速\n$color${downspeedgraph wlp2s0 32,150 ff0000 0000ff}${upspeedgraph wlp2s0 32,150 ff0000 0000ff}\n$color1${offset 50}${voffset 20}$template1${downspeed wlp2s0}$alignr${offset -40}${upspeed wlp2s0}\n#绘制横线\n${stippled_hr}\n#监视内存\n$template1$color1 Men: ${offset 9}$color$alignr$mem / $memmax\n#监视进程\n$color1 Proc: $color$alignr${processes}\n#监视温度\n$color1$color1 Temp:  $alignr$color${acpitemp}\n#监视IP\n$color$template1$color1 IP: $alignr$color${addr wlp2s0}\n#${image /home/jinelei/Picture/test.jpg  -s 300x700 }\n#绘制横线\n${stippled_hr}\n\n${color1}RAM ${color1}${alignr}${mem}\n${color1}${membar 5,}\n${color1}$template1${top_mem name 1} $alignr ${color2} ${top_mem mem_res 1}\n${color1}$template1${top_mem name 2} $alignr ${color2} ${top_mem mem_res 2}\n${color1}$template1${top_mem name 3} $alignr ${color2} ${top_mem mem_res 3}\n${color1}$template1${top_mem name 4} $alignr ${color2} ${top_mem mem_res 4}\n${color1}$template1${top_mem name 5} $alignr ${color2} ${top_mem mem_res 5}\n${color1}$template1${top_mem name 6} $alignr ${color2} ${top_mem mem_res 6}\n${color1}$template1${top_mem name 7} $alignr ${color2} ${top_mem mem_res 7}\n${color1}$template1${top_mem name 8} $alignr ${color2} ${top_mem mem_res 8}\n${color1}$template1${top_mem name 9} $alignr ${color2} ${top_mem mem_res 9}\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"i3wm配置文件","url":"/2018/11/08/i3wm/","content":"\n我的i3wm配置\n\n```\n# This file has been auto-generated by i3-config-wizard(1).\n# It will not be overwritten, so edit it as you like.\n#\n# Should you change your keyboard layout some time, delete\n# this file and re-run i3-config-wizard(1).\n#\n\n# i3 config file (v4)\n#\n# Please see http://i3wm.org/docs/userguide.html for a complete reference!\n\nset $mod Mod4\n\n# Font for window titles. Will also be used by the bar unless a different font\n# is used in the bar {} block below.\nfont pango:DejaVu Sans Mono, Icons 16\n\n# This font is widely installed, provides lots of unicode glyphs, right-to-left\n# text rendering and scalability on retina/hidpi displays (thanks to pango).\n#font pango:DejaVu Sans Mono 8\n\n# Before i3 v4.8, we used to recommend this one as the default:\n# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1\n# The font above is very space-efficient, that is, it looks good, sharp and\n# clear in small sizes. However, its unicode glyph coverage is limited, the old\n# X core fonts rendering does not support right-to-left and this being a bitmap\n# font, it doesn’t scale on retina/hidpi displays.\n\n# Use Mouse+$mod to drag floating windows to their wanted position\nfloating_modifier $mod\n\n# start a terminal\nbindsym $mod+Return exec i3-sensible-terminal\n\n# kill focused window\nbindsym $mod+Shift+c kill\n\n# start dmenu (a program launcher)\n#bindsym $mod+d exec dmenu_run\nbindsym $mod+d exec \"rofi -combi-modi window,drun -show combi -modi combi\"\nbindsym $mod+p exec \"rofi -combi-modi window,drun -show combi -modi combi\"\n\nbindsym $mod+a exec \"arandr\"\n# There also is the (new) i3-dmenu-desktop which only displays applications\n# shipping a .desktop file. It is a wrapper around dmenu, so you need that\n# installed.\n# bindsym $mod+d exec --no-startup-id i3-dmenu-desktop\n#\n\n# jinelei\n\nnew_window pixel 3\nhide_edge_borders smart\nbindsym $mod+b bar mode toggle\n\n# Toggle between stacking/tabbed/split:\nbindsym $mod+x layout toggle\n\n# switch between the current and the previously focused one\nbindsym $mod+Escape workspace back_and_forth\nbindsym $mod+Shift+Escape move container to workspace back_and_forth\n\n\n# Press $mod+o followed by either f, t, Esc or Return to launch firefox,\n# thunderbird or return to the default mode, respectively.\n#set $mode_launcher Launch: [f]irefox [g]chromium\n#bindsym $mod+o mode \"$mode_launcher\"\n#\n#mode \"$mode_launcher\" {\n#    bindsym f exec firefox\n#    bindsym g exec chromium\n#\n#    bindsym Esc mode \"default\"\n#    bindsym Return mode \"default\"\n#}\n\n## Manual management of external displays\n# Set the shortcuts and what they do\nset $mode_display Ext Screen [r] right of eDP1 [f] HDMI2 off\nmode \"$mode_display\" {\n    bindsym r exec --no-startup-id xrandr --output HDMI2 --auto --right-of eDP1 --mode 1920x1080\n    #bindsym h exec --no-startup-id xrandr --output HDMI2 --auto --right-of eDP1 --mode\n    bindsym f exec --no-startup-id xrandr --output HDMI2 --off\n    #bindsym y exec --no-startup-id xrandr --output HDMI2 --auto --off --mode\n\n    # back to normal: Enter or Escape\n    bindsym Return mode \"default\"\n    bindsym Escape mode \"default\"\n}\n# Declare here the shortcut to bring the display selection menu\n#bindsym $mod+p mode \"$mode_display\"\n\n# jinelei mouse keybind\n# The middle button over a titlebar kills the window\nbindsym --release button2 kill\n\n# The middle button and a modifer over any part of the window kills the window\nbindsym --whole-window $mod+button2 kill\n\n# The right button toggles floating\nbindsym button3 floating toggle\nbindsym $mod+button3 floating toggle\n\n# The side buttons move the window around\nbindsym button9 move left\nbindsym button8 move right\n\n\n# change focus\nbindsym $mod+h focus left\nbindsym $mod+j focus down\nbindsym $mod+k focus up\nbindsym $mod+l focus right\n\n# alternatively, you can use the cursor keys:\nbindsym $mod+Left focus left\nbindsym $mod+Down focus down\nbindsym $mod+Up focus up\nbindsym $mod+Right focus right\n\n# move focused window\nbindsym $mod+Shift+h move left\nbindsym $mod+Shift+j move down\nbindsym $mod+Shift+k move up\nbindsym $mod+Shift+l move right\n\n# alternatively, you can use the cursor keys:\nbindsym $mod+Shift+Left move left\nbindsym $mod+Shift+Down move down\nbindsym $mod+Shift+Up move up\nbindsym $mod+Shift+Right move right\n\n# split in horizontal orientation\nbindsym $mod+c split h\n\n# split in vertical orientation\nbindsym $mod+v split v\n\n# enter fullscreen mode for the focused container\nbindsym $mod+f fullscreen toggle\n\n# change container layout (stacked, tabbed, toggle split)\nbindsym $mod+s layout stacking\nbindsym $mod+w layout tabbed\nbindsym $mod+e layout toggle split\n\n# toggle tiling / floating\nbindsym $mod+Shift+space floating toggle\n\n# change focus between tiling / floating windows\nbindsym $mod+space focus mode_toggle\n\n# focus the parent container\n#bindsym $mod+a focus parent\n\n# focus the child container\n#bindsym $mod+d focus child\n\n# switch to workspace\nset  $WS1 1:web\nset  $WS2 2:devel\nset  $WS3 3:term\nset  $WS4 4:gimp\nset  $WS5 5:vlc\nset  $WS6 6:pi\nset  $WS7 7:file\nset  $WS8 8:misc\nset  $WS9 9:other\nset  $WS10 10:daemo\n\n\n\n# switch to workspace\nbindsym $mod+1 workspace $WS1\nbindsym $mod+2 workspace $WS2\nbindsym $mod+3 workspace $WS3\nbindsym $mod+4 workspace $WS4\nbindsym $mod+5 workspace $WS5\nbindsym $mod+6 workspace $WS6\nbindsym $mod+7 workspace $WS7\nbindsym $mod+8 workspace $WS8\nbindsym $mod+9 workspace $WS9\nbindsym $mod+0 workspace $WS10\n\n# move focused container to workspace\nbindsym $mod+Shift+1 move container to workspace $WS1\nbindsym $mod+Shift+2 move container to workspace $WS2\nbindsym $mod+Shift+3 move container to workspace $WS3\nbindsym $mod+Shift+4 move container to workspace $WS4\nbindsym $mod+Shift+5 move container to workspace $WS5\nbindsym $mod+Shift+6 move container to workspace $WS6\nbindsym $mod+Shift+7 move container to workspace $WS7\nbindsym $mod+Shift+8 move container to workspace $WS8\nbindsym $mod+Shift+9 move container to workspace $WS9\nbindsym $mod+Shift+0 move container to workspace $WS10\n# reload the configuration file\n#bindsym $mod+Shift+c reload\n# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)\nbindsym $mod+Shift+r restart\n# exit i3 (logs you out of your X session)\n#bindsym $mod+Shift+e exec \"i3-nagbar -t warning -m 'You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.' -b 'Yes, exit i3' 'i3-msg exit'\"\nbindsym $mod+Shift+e exec \"i3-msg exit\"\n\n#jinelei\n\nbindsym XF86MonBrightnessDown exec \"xbacklight -10\"\nbindsym XF86MonBrightnessUp exec \"xbacklight +10\"\nbindsym XF86AudioMute exec \"amixer sset Master toggle\"\nbindsym XF86AudioLowerVolume exec \"amixer sset Master 5%-\"\nbindsym XF86AudioRaiseVolume exec \"amixer sset Master 5%+\"\n#bindsym XF86AudioRaiseVolume exec \"amixer sset Master 5%+\"\nbindsym $mod+g exec \"chromium\"\nbindsym $mod+i exec \"intellij-idea-ultimate-edition\"\n\n# move to workspace\nfor_window [class=\"Chromium\"]  move container to workspace $WS1\nfor_window [class=\"jetbrains-idea\"]  move container to workspace $WS2\nfor_window [class=\"Gimp\"] move container to workspace $WS4\nfor_window [class=\"Vlc\"]  move container to workspace $WS5\nfor_window [class=\"Arandr\"] floating enable\nfor_window [class=\"ffplay\"] floating enable\n\n\n# resize window (you can also use the mouse for that)\nmode \"resize\" {\n        # These bindings trigger as soon as you enter the resize mode\n\n        # Pressing left will shrink the window’s width.\n        # Pressing right will grow the window’s width.\n        # Pressing up will shrink the window’s height.\n        # Pressing down will grow the window’s height.\n        bindsym h resize shrink width 10 px or 10 ppt\n        bindsym j resize grow height 10 px or 10 ppt\n        bindsym k resize shrink height 10 px or 10 ppt\n        bindsym l resize grow width 10 px or 10 ppt\n\n        # same bindings, but for the arrow keys\n        bindsym Left resize shrink width 10 px or 10 ppt\n        bindsym Down resize grow height 10 px or 10 ppt\n        bindsym Up resize shrink height 10 px or 10 ppt\n        bindsym Right resize grow width 10 px or 10 ppt\n\n        # back to normal: Enter or Escape\n        bindsym Return mode \"default\"\n        bindsym Escape mode \"default\"\n}\n\nbindsym $mod+r mode \"resize\"\n\n# Start i3bar to display a workspace bar (plus the system information i3status\n# finds out, if available)\nbar {\n    output            eDP1\n    status_command    i3status\n    #mode              hide\n    workspace_buttons yes\n    tray_output       none\n\n    #font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1\n    font pango:DejaVu Sans Mono, Icons 16\n\n    colors {\n        background #000000\n        statusline #ffffff\n\n        focused_workspace  #ffffff #285577\n        active_workspace   #ffffff #333333\n        inactive_workspace #888888 #222222\n        urgent_workspace   #ffffff #900000\n    }\n}\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"IE8下无法创建automation对象","url":"/2018/11/08/ie8-automation/","content":"\n问题描述：使用```new ActiveXObject(\"Scripting.FileSystemObject\");```创建对象时，抱错```automation服务器不能创建对象```\n\n方法一：通过internet安全设置\n1. 打开***工具***菜单，选择internet选项\n2. 点击安全选项卡，选择自定义级别\n3. 把下面几项设置为启用：\n    1. ***对标记为可安全执行脚本的ActiveX控件执行脚本***\n    1. ***对未标记为可安全执行脚本的ActiveX控件执行脚本***\n    1. ***运行ActiveX控件和插件***\n    1. ***仅允许经过批准的域在未经提示的情况下使用ActiveX***\n4. 保存设置\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"IE8下trim()失效","url":"/2018/11/08/ie8-trim-fix/","content":"\n经测试，IE8不支持trim()方法，先发现两种替代方案。\n\n1. jquery：\n```js\n$.trim(str)\n```\n> 注意jquery版本\n2. 原生方法 \n ```js\nString.prototype.trim = function () {\n    return this.replace(/(^\\s*)|(\\s*$)/g, \"\");\n}\nString.prototype.ltrim = function () {\n    return this.replace(/(^\\s*)/g, \"\");\n}\nString.prototype.rtrim = function () {\nreturn this.replace(/(\\s*$)/g, \"\");\n}\n```\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"vimrc 配置示例","url":"/2018/11/08/vimrc/","content":"\n1. 安装Vbundle\n```git clone https://github.com/gmarik/Vundle.vim.git  ~/.vim/bundle/Vundle.vim```\n\n2. 使用vimrc\n{% raw %}\n```\n\"{{{ 一般设置\nset nu\nset nocompatible                    \" be iMproved, required\nset autoindent\nset tabstop=4\nset shiftwidth=4\nset softtabstop=4\nset expandtab\n\"}}}\n\n\"{{{语法检测设定\nfiletype    on                      \" 检测打开文件的类型\nsyntax      on                      \" 开启语法高亮\nsyntax      enable                  \" 激活语法高亮\nfiletype    plugin on               \" 允许特定的文件类型载入插件文件\nfiletype    indent on               \" 允许特定的文件类型载入缩进文件\n\"}}}\n\n\"{{{ 搜索和匹配\nset showmatch                       \" 高亮显示匹配的括号\nset matchtime=5                     \" 匹配括号高亮的时间(单位是十分之一秒)\nset ignorecase                      \" 搜索时忽略大小写\nset smartcase                       \" 如果搜索模式包含大写字符，不使用'ignorecase'选项\nset hlsearch                        \" 高亮被搜索的内容\nset incsearch                       \" 增量搜索\n\"}}}\n\n\"{{{ 缩进/换行/空白/行号/折叠/滚动\nset autoindent                      \" 开启新行时，自动缩进\nset smartindent                     \" 开启新行时，智能缩进\nset cindent                         \" C程序自动缩进\n\"}}}\n\n\"{{{ 编码及存储\nset fileencodings=utf-8             \" 文件编码，强制UTF-8\nset encoding=utf-8                  \" vim内部编码\nset nobomb                          \" 不使用bom编码\nset nobackup                        \" 不使用备份文件\nset noswapfile                      \" 不产生交换文件\nset autoread                        \" 自动同步外部修改\nset autowrite                       \" 自动把内容写回文件\n\"}}}\n\n\"{{{ 快捷键设置\nmap <F5> :call CompileRunGcc()<CR>  \" C\nfunc! CompileRunGcc()\nexec \"w\"\nexec \"!gcc % -o %<\"\nexec \"! ./%<\"\nendfunc\n\" C++\nmap <F6> :call CompileRunGpp()<CR>\nfunc! CompileRunGpp()\nexec \"w\"\nexec \"!g++ % -o %<\"\nexec \"! ./%<\"\nendfunc\n\"}}}\n\n\"{{{ CtrlP 设置\nset runtimepath^=~/.vim/bundle/ctrlp.vim\n\"}}}\n\n\"{{{ 主题设置\nlet g:airline#extensions#tabline#enabled = 1 \" 显示tabline\n\"}}}\n\n\"{{{ 自动符号匹配\ninoremap ( ()<Esc>:let leavechar=\")\"<CR>i\ninoremap [ []<Esc>:let leavechar=\"]\"<CR>i\ninoremap { {}<Esc>:let leavechar=\"}\"<CR>i\n\"inoremap < <><Esc>:let leavechar=\">\"<CR>i\n\"inoremap ” “”<Esc>:let leavechar=\"\"\"<CR>i\n\"inoremap ' ''<Esc>:let leavechar=\"'\"<CR>i\n\"}}}\n\n\"{{{ 彩虹符号\nlet g:rainbow_active = 1\nlet g:rainbow_operators=2\nlet g:rainbow_conf = {\n            \\   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],\n            \\   'ctermfgs': ['lightgray', 'lightblue', 'lightmagenta', 'lightcyan'],\n            \\   'operators': '_,_',\n            \\   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\\[/ end=/\\]/ fold', 'start=/{/ end=/}/ fold'],\n            \\   'separately': {\n            \\       '*': {},\n            \\       'lisp': {\n            \\           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],\n            \\           'ctermfgs': ['darkgray', 'darkblue', 'darkmagenta', 'darkcyan', 'darkred', 'darkgreen'],\n            \\       },\n            \\       'vim': {\n            \\           'parentheses': [['fu\\w* \\s*.*)','endfu\\w*'], ['for','endfor'], ['while', 'endwhile'], ['if','_elseif\\|else_','endif'], ['(',')'], ['\\[','\\]'], ['{','}']],\n            \\       },\n            \\       'tex': {\n            \\           'parentheses': [['(',')'], ['\\[','\\]'], ['\\\\begin{.*}','\\\\end{.*}']],\n            \\       },\n            \\       'css': 0,\n            \\       'stylus': 0,\n            \\   }\n            \\}\n\"}}}\n\n\"{{{ NERDTree设置\n\"\"将F2设置为开关NERDTree的快捷键\nmap <f2> :NERDTreeToggle<cr>\n\"\"修改树的显示图标\nlet g:NERDTreeDirArrowExpandable = '+'\nlet g:NERDTreeDirArrowCollapsible = '-'\n\"\"窗口位置\nlet g:NERDTreeWinPos='right'\n\"\"窗口尺寸\nlet g:NERDTreeSize=30\n\"\"窗口是否显示行号\nlet g:NERDTreeShowLineNumbers=1\n\"\"不显示隐藏文件\nlet g:NERDTreeHidden=1\n\"\"打开vim时如果没有文件自动打开NERDTree\nautocmd vimenter * if !argc()|NERDTree|endif\n\"\"当NERDTree为剩下的唯一窗口时自动关闭\nautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) | q | endif\n\"\"打开vim时自动打开NERDTree\n\"autocmd vimenter * NERDTree\nlet g:NERDTreeIndicatorMapCustom = {\n            \\ \"Modified\" : \"✹\",\n            \\ \"Staged\" : \"✚\",\n            \\ \"Untracked\" : \"✭\",\n            \\ \"Renamed\" : \"➜\",\n            \\ \"Unmerged\" : \"═\",\n            \\ \"Deleted\" : \"✖\",\n            \\ \"Dirty\" : \"✗\",\n            \\ \"Clean\" : \"✔︎\",\n            \\ \"Unknown\" : \"?\"\n            \\ }\n\"}}}\n\n\"{{{ Plugin设置\nfiletype off                  \" required\n\" VBundle配置\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\nPlugin 'VundleVim/Vundle.vim'\n\" 主题\nPlugin 'vim-airline/vim-airline'\nPlugin 'vim-airline/vim-airline-themes'\n\" NERDTree\nPlugin 'git://git.wincent.com/command-t.git'\nPlugin 'git://github.com/scrooloose/nerdtree.git'\nPlugin 'git://github.com/Xuyuanp/nerdtree-git-plugin.git'\n\" 彩虹括号\nPlugin 'luochen1990/rainbow'\n\" markdown插件\nPlugin 'tpope/vim-markdown'\n\" 围绕\nPlugin 'tpope/vim-surround'\n\" 重复\nPlugin 'tpope/vim-repeat'\n\" git\nPlugin 'airblade/vim-gitgutter'\n\"\ncall vundle#end()            \" required\nfiletype plugin indent on    \" required\n\"}}}\n```\n{% endraw %}\n\n\n3. 安装Bundle\n进入vim，进入安装```BundleInstall```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"探测远程ip","url":"/2018/11/07/shell-detect-remote-ip/","content":"\n```\n#!/bin/sh\n\nIP_ADDR=192.168.1.150\t\t\t\t\t\t\t\t\t#目标IP地址\nDETAIL_LOG=/var/log/ping_remote_detail_log.log\t\t\t#详细日志文件\nLOG=/var/log/ping_remote_log.log\t\t\t\t\t\t#日志简报\nDATE=`date  \"+%F %H:%m:%S\"`\t\t\t\t\t\t\t\t#时间\nPING_COUNT=9\t\t\t\t\t\t\t\t\t\t\t#ping的次数\nBLACK_ROW=`expr $PING_COUNT + 2`\t\t\t\t\t\t#要删除的空行的行数\nCOUNT_INFO_ROW=`expr $PING_COUNT + 4`\t\t\t\t\t#简报要统计的信息所在行\n\nping -c $PING_COUNT \"$IP_ADDR\" \\\n\t|awk 'BEGIN{print \"--------------------\", \"'\"$DATE\"'\", \"---------------------\"} NR != \"'\"$BLACK_ROW\"'\" {print} END{print \"--------------------------------------------------------------\\n\"}' \\\n\t|tee -a \"$DETAIL_LOG\" \\\n\t|awk -F'[, ]' 'NR == \"'\"$COUNT_INFO_ROW\"'\" {print \"'\"$DATE\"'\", $1, $5, $8}' OFS='\\t' \\\n\t|tee -a \"$LOG\" \\\n\t&> /dev/null\n  ```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"js制作svg时钟","url":"/2018/11/07/svg-clock-memo/","content":"\n1. 声明创建表盘函数\n```js\nfunction createDialPlate(attr, attrBackground, point1, point2, parentEle) {\n    let dialPlate = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    let dialPalteBackground = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    for (let k in attr)\n        dialPlate.setAttribute(k, attr[k]);\n    for (let k in attrBackground)\n        dialPalteBackground.setAttribute(k, attrBackground[k]);\n    parentEle.appendChild(dialPalteBackground);\n    parentEle.appendChild(dialPlate);\n    for (let i = 0; i < 360; i += 6) {\n        let point = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        if (i % 30 == 0) {\n            for (let k in point1)\n                point.setAttribute(k, point1[k]);\n        } else {\n            for (let k in point2)\n                point.setAttribute(k, point2[k]);\n        }\n        point.setAttribute('transform', 'rotate(' + i + ', ' + attr['cx'] + ', ' + attr['cx'] + ')');\n        parentEle.appendChild(point);\n    }\n}\n```\n\n2. 声明创建指针函数\n```js\nfunction createClockPoint(plate, attr, dur, nowDeg, parentEle) {\n    let point = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    for (let k in attr) {\n        point.setAttribute(k, attr[k]);\n    }\n    let pointAnimateTransform = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');\n    pointAnimateTransform.setAttribute('attributeName', 'transform');\n    pointAnimateTransform.setAttribute('type', 'rotate');\n    pointAnimateTransform.setAttribute('begin', '0s');\n    pointAnimateTransform.setAttribute('dur', dur);\n    pointAnimateTransform.setAttribute('from', nowDeg + ' ' + plate['cx'] + ' ' + plate['cy']);\n    pointAnimateTransform.setAttribute('to', (nowDeg + 360) + ' ' + plate['cx'] + ' ' + plate['cy']);\n    pointAnimateTransform.setAttribute('repeatCount', 'indefinite');\n    point.appendChild(pointAnimateTransform);\n    parentEle.appendChild(point);\n}\n```\n3. 初始化表盘\n```js\nfunction initDialPlate() {\n    let dialPlateRadius = 70;\n    let dialPlateBgRadius = dialPlateRadius * 1.2;\n    let svgStyle = {\n        id: 'main',\n        version: '1.1',\n        height: dialPlateBgRadius * 2,\n        width: dialPlateBgRadius * 2\n    };\n    let svg = document.createElementNS(\"http://www.w3.org/2000/svg\", 'svg');\n    for (k in svgStyle)\n        svg.setAttribute(k, svgStyle[k]);\n    let dialPlateStyle = {\n        'r': dialPlateRadius,\n        'class': 'fancy',\n        'cx': dialPlateBgRadius,\n        'cy': dialPlateBgRadius,\n        'style': 'fill: #2A3039'\n    };\n    let dialPlateBgStyle = {\n        'r': dialPlateBgRadius,\n        'class': 'fancy',\n        'cx': dialPlateBgRadius,\n        'cy': dialPlateBgRadius,\n        'style': 'fill: #1D2126'\n    };\n    let dialDot1Style = {\n        'width': Math.ceil(dialPlateRadius / 30),\n        'height': Math.ceil(dialPlateRadius / 8),\n        'x': dialPlateBgRadius,\n        'y': dialPlateBgRadius - dialPlateRadius,\n        'rx': '3',\n        'ry': '3',\n        'style': 'stroke: #cccccc; fill: #cccccc',\n    };\n    let dialDot2Style = {\n        'width': Math.ceil(dialPlateRadius / 30),\n        'height': Math.ceil(dialPlateRadius / 20),\n        'x': dialPlateBgRadius,\n        'y': dialPlateBgRadius - dialPlateRadius,\n        'rx': '3',\n        'ry': '3',\n        'style': 'stroke: #cccccc; fill: #cccccc',\n    };\n    let secondPointStyle = {\n        x: dialPlateBgRadius,\n        y: dialPlateBgRadius * 0.6,\n        width: '1',\n        height: dialPlateRadius * 1.4,\n        rx: '2',\n        ry: '2',\n        style: \"fill: #EA5432; stroke: #EA5432; stroke-width: \" + Math.ceil(dialPlateRadius / 35),\n    };\n    let minutePointStyle = {\n        x: dialPlateBgRadius,\n        y: dialPlateBgRadius,\n        width: '1',\n        height: dialPlateRadius * 0.8,\n        rx: '2',\n        ry: '2',\n        style: \"fill: #cccccc; stroke: #cccccc; stroke-width: \" + Math.ceil(dialPlateRadius / 25),\n    };\n    let hourPointStyle = {\n        x: dialPlateBgRadius,\n        y: dialPlateBgRadius,\n        width: '1',\n        height: dialPlateRadius * 0.6,\n        rx: '2',\n        ry: '2',\n        style: \"fill: #cccccc; stroke: #cccccc; stroke-width: \" + Math.ceil(dialPlateRadius / 20),\n    };\n    createDialPlate(dialPlateStyle, dialPlateBgStyle, dialDot1Style, dialDot2Style, svg);\n    let date = new Date();\n    let hour = date.getHours();\n    let minute = date.getMinutes();\n    let second = date.getSeconds();\n    let milli = date.getMilliseconds();\n    createClockPoint(dialPlateBgStyle, hourPointStyle, '259200s', 30 * hour + 30 / 60 * minute - 180, svg);\n    createClockPoint(dialPlateBgStyle, minutePointStyle, '3600s', 6 * minute + 6 * second / 60 - 180, svg);\n    createClockPoint(dialPlateBgStyle, secondPointStyle, '60s', 6 * second + 6 * milli / 1000 - 180, svg);\n    let dialPlateDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    dialPlateDot.setAttribute('cx', dialPlateBgStyle['cx']);\n    dialPlateDot.setAttribute('cy', dialPlateBgStyle['cy']);\n    dialPlateDot.setAttribute('r', dialPlateRadius / 20);\n    dialPlateDot.setAttribute('style', 'fill: #EA5432; stroke: #EA5432; stroke-width: ' + Math.ceil(dialPlateRadius / 20));\n    svg.appendChild(dialPlateDot);\n    document.body.appendChild(svg);\n};\n```\n4. 添加到window.load中去\n```js\nwindow.addEventListener('load', initDialPlate);\n```\n\n> 创建元素时要使用  \n> ```document.createElementNS(''http://www.w3.org/2000/svg', 'circle');```\n> 添加元素要使用  \n> ```ele.setAttribute('width', '100');```\n> 动画使用  \n> ```animateTransform```\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"ffmpeg自动推流到指定ip","url":"/2018/11/06/ffmpeg-auto-push/","content":"\n```\n#!/bin/bash\nvideo_dir=\"/home/jinelei/videos\"\nserver_ip=\"192.168.31.169\"\ndefault_stream_name=\"video\"\ndefault_index=\"0\"\nflag=0\nwhile getopts \"d:f:s:i:Hh\" arg\ndo\n    case $arg in\n        d)\n            video_dir=$OPTARG\n            ;;\n        i)\n            server_ip=$OPTARG\n            ;;\n        ?)\n            echo \"Usage jin-auto-ffmpeg [-d][dir_name] [-i][server_ip]\"\n            ;;\n    esac\ndone\n\nif [ -e $video_dir ]\nthen\n    flag=`echo \"$flag+1\"|bc`\nelse\n    echo \"please input vaild dir name\"\nfi\nif [ -n \"`echo $server_ip|sed -n \"/^.*\\..*\\..*\\..*\\$/p\"`\" ]\nthen\n    flag=`echo \"$flag+1\"|bc`\nelse\n    echo \"please input vaild ip address\"\nfi\n\ntmp_fifo_file=\"/tmp/$$.fifo\"\nmkfifo $tmp_fifo_file\nexec 4<> $tmp_fifo_file\nrm -rf $tmp_fifo_file\n\nif [ $flag -eq 2 ] \nthen\n    for tmp_name in `ls $video_dir`\n    do\n        if [ -n \"`echo $tmp_name|sed -n \"/^.*\\.mp4\\$/p\"`\" ]\n        then\n            video_file_name=$tmp_name;\n            #video_stream_name=${tmp_name%%.mp4}\n            video_stream_name=\"$default_stream_name$default_index\"\n            default_index=`echo \"$default_index+1\"|bc`\n            {\n            ffmpeg -re -i \"$video_dir/$video_file_name\"  -codec:v libx264 -acodec aac -f flv -c copy \"rtmp://$server_ip:1935/live/$video_stream_name\" >> /dev/null\n            }&\n        fi\n    done;\nelse\n    echo \"Usage jin-ffmpeg [-d][dir_name] [-i][server_ip]\"\nfi\n\nwait\nexec 4>&-\nexit\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"css伪类","url":"/2018/11/05/pseudo-class/","content":"\njs查看伪类的css样式\n\n```js\ndocument.defaultView.getComputedStyle(ele, ':before');\n```\n>  `document.defaultView`在浏览器中，该属性返回当前 document 对象所关联的 window 对象，如果没有，会返回 null。\n>> 该属性只读.\n>\n>> 根据 [quirksmode](http://www.quirksmode.org/dom/w3c_html.html)，IE 9 以下版本不支持 defaultView。\n>\n> `Window.getComputedStyle(element, [pseudoElt])`方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。\n>> `element`用于获取计算样式的[Element](https://developer.mozilla.org/zh-CN/docs/Web/API/Element)\n>\n>> `pseudoElt`指定一个要匹配的[伪元素](https://drafts.csswg.org/css-content-3/#pseudo-elements)的字符串。必须对普通元素省略（或null）\n>\n>> 返回的style是一个实时的[CSSStyleDeclaration](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration)对象，当元素的样式更改时，它会自动更新本身。\n>>> CSS属性值可以使用getPropertyValue(propName)API或直接索引到对象，如cs ['z-index']或cs.zIndex。\n\n\n伪类的点击事件\n\n> 通过禁用元素的点击，启用伪类的点击\n```js\npre {\n  text-indent: -1em;\n  & > code {\n    pointer-events: none;\n    margin: 0 1em;\n    &::before {\n      text-indent: 0em;\n      pointer-events: auto;\n      width: 3em;\n      position: absolute;\n      border-radius: 5px;\n      padding: 0.3em .5em;\n      margin: 0.5em;\n      content: 'copy';\n      background-color: rgba(0, 0, 0, 0.3);\n      color: rgba(255, 255, 255, 0.9);\n    }\n    &:hover::before {\n      background-color: rgba(100, 100, 100, 0.7);\n      color: rgba(0, 0, 0, 0.8);\n    }\n  }\n}\n```\n","tags":["学习笔记"],"categories":["CSS"]},{"title":"xrandr调整亮度","url":"/2018/11/05/xrandr-adjust-brightness/","content":"\n```\n#!/bin/bash\n#default eDP1\nDEV=\"eDP-1\"\nNUM=1\nwhile getopts \"o:n:\" arg\ndo\n    case $arg in\n        o)\n            DEV=$OPTARG\n            ;;\n        n)\n            tmp=`echo \"scale=1;$OPTARG/10\"| bc`\n            NUM=$tmp\n            ;;\n        ?)\n            ;;\n    esac\ndone\n\nif [ $# -ge 1 ]\nthen\n    xrandr --output $DEV --brightness $NUM\nelse\n    xrandr | grep -v \"disconnected\" |  grep \"connected\"  \nfi\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"css3 box-sizing说明","url":"/2018/11/04/css-box-sizing/","content":"\nbox-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。\n\n> content-box: ***默认值*** 任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中 \n>> 1. width = 内容的宽度\n>> 1. height = 内容的高度。\n>\n> border-box: 边框和内边距的值是包含在width内\n>> 1. width = border + padding + 内容的  width\n>> 1. height = border + padding + 内容的 height\n \n参考[MDN box-sizing](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing)\n\n","categories":["CSS"]},{"title":"ie8 juqery bootstrap兼容性","url":"/2018/11/01/ie8-bootstrap/","content":"\n如何使bootstrap兼容IE8.\n\n1. 把[jquery.min.js](https://cdn.bootcss.com/jquery/1.12.0/jquery.min.js)下载下来，放在本地资源中，使用本地资源url，而不是用cdn加速，保证同一域名下，不跨域\n2. 下载[html5shiv.js](https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js)，并在jquery之后引入\n3. 下载[response.min.js](https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js)，并在jquery之后引入\n4. 在</head>之前添加以下代码：\n\n```\n<!--[if lt IE 9]>\n    <script src=\"js/html5shiv.js\"/>\n    <script src=\"js/respond.min.js\"/>\n<![endif]-->\n\n```\n\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"react-native代码段","url":"/2018/05/24/rn-snippet/","content":"\n- ##### 引用图片\n\n\t-  普通方式\n\n\t```<Image source={require('../assets/functions/mod_addressbook.imageset/mod_addressbook.webp')} />```\n\n\t- 动态引用\n\n\t```\n\tvar icon = this.props.active ? require('./my-icon-active.webp') : require('./my-icon-inactive.webp');\n\t<Image source={icon} />\n\t```\n\n\n\n\n\n","tags":["学习笔记"],"categories":["RectNative"]},{"title":"iOS集成react-native","url":"/2018/05/23/rn-ios-integrate/","content":"\n1. 新建react-native工程\n\n```react-native init demo --version 0.44.3```\n> 注意这里指定了版本的react-native，高版本的react-native可能会编译错误主要是自己太菜了。\n\n\n\n\n2. 删除ios目录下的文件，拷贝从xcode创建的新工程的文件到ios目录下，并添加PodFile，样例如下:\n\n```\nplatform :ios, '8.0'\nuse_frameworks!\n\n# target的名字一般与你的项目名字相同，我这里项目名是demo\ntarget 'demo' do\n\n  # 'node_modules'目录一般位于根目录中\n  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`\n  pod 'React', :path => '../node_modules/react-native', :subspecs => [\n    'Core',\n    'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单\n    'RCTText',\n    'RCTNetwork',\n    'RCTWebSocket', # 这个模块是用于调试功能的\n    # 在这里继续添加你所需要的RN模块\n  ]\n  # 如果你的RN版本 >= 0.42.0，则加入下面这行\n  pod \"Yoga\", :path => \"../node_modules/react-native/ReactCommon/yoga\"\n\nend\n\n```\n\n3. 执行```pod install```安装依赖，安装完成后会产生Pods、Podfile.lock等文件。\n\n4. 使用xcode打开```demo.xcworkspac```文件，添加一对ViewController，命名为RNViewController.h、RNViewController.m，文件内容如下：\n\nRNViewController.h\n```\n#import <Foundation/Foundation.h>\n#import <React/RCTRootView.h>\n\n\n@interface RNViewController : UIViewController\n\n@end\n```\n\nRNViewController.m\n```\n#import \"RNViewController.h\"\n\n@implementation RNViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"demo\"\n                                                  initialProperties:nil\n                                                      launchOptions:nil];\n    self.view = rootView;\n    // Do any additional setup after loading the view.\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n@end\n```\n\n5. 添加布局（由于ios不熟，所以使用了```main.storyboard```编辑，内容如下：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<document type=\"com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB\" version=\"3.0\" toolsVersion=\"11762\" systemVersion=\"16B2657\" targetRuntime=\"iOS.CocoaTouch\" propertyAccessControl=\"none\" useAutolayout=\"YES\" useTraitCollections=\"YES\" colorMatched=\"YES\" initialViewController=\"Gb4-UD-klr\">\n    <device id=\"retina4_7\" orientation=\"portrait\">\n        <adaptation id=\"fullscreen\"/>\n    </device>\n    <dependencies>\n        <deployment identifier=\"iOS\"/>\n        <plugIn identifier=\"com.apple.InterfaceBuilder.IBCocoaTouchPlugin\" version=\"11757\"/>\n        <capability name=\"documents saved in the Xcode 8 format\" minToolsVersion=\"8.0\"/>\n    </dependencies>\n    <scenes>\n        <!--Navigation Controller-->\n        <scene sceneID=\"jZv-Eb-kDK\">\n            <objects>\n                <navigationController id=\"Gb4-UD-klr\" sceneMemberID=\"viewController\">\n                    <navigationBar key=\"navigationBar\" contentMode=\"scaleToFill\" id=\"Th1-FI-dxd\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"375\" height=\"44\"/>\n                        <autoresizingMask key=\"autoresizingMask\"/>\n                    </navigationBar>\n                    <connections>\n                        <segue destination=\"BYZ-38-t0r\" kind=\"relationship\" relationship=\"rootViewController\" id=\"UwD-kE-QAJ\"/>\n                    </connections>\n                </navigationController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"ma8-aZ-VDt\" userLabel=\"First Responder\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"-823\" y=\"127\"/>\n        </scene>\n        <!--我是原生界面-->\n        <scene sceneID=\"tne-QT-ifu\">\n            <objects>\n                <viewController id=\"BYZ-38-t0r\" customClass=\"ViewController\" sceneMemberID=\"viewController\">\n                    <layoutGuides>\n                        <viewControllerLayoutGuide type=\"top\" id=\"y3c-jy-aDJ\"/>\n                        <viewControllerLayoutGuide type=\"bottom\" id=\"wfy-db-euE\"/>\n                    </layoutGuides>\n                    <view key=\"view\" contentMode=\"scaleToFill\" id=\"8bC-Xf-vdC\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"375\" height=\"667\"/>\n                        <autoresizingMask key=\"autoresizingMask\" widthSizable=\"YES\" heightSizable=\"YES\"/>\n                        <subviews>\n                            <button opaque=\"NO\" contentMode=\"scaleToFill\" contentHorizontalAlignment=\"center\" contentVerticalAlignment=\"center\" buttonType=\"roundedRect\" lineBreakMode=\"middleTruncation\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"ewF-NN-AX5\">\n                                <rect key=\"frame\" x=\"139.5\" y=\"318.5\" width=\"97\" height=\"30\"/>\n                                <state key=\"normal\" title=\"跳转至RN界面\"/>\n                                <connections>\n                                    <segue destination=\"uMO-xq-gw5\" kind=\"show\" id=\"PLm-J8-SMi\"/>\n                                </connections>\n                            </button>\n                        </subviews>\n                        <color key=\"backgroundColor\" red=\"1\" green=\"1\" blue=\"1\" alpha=\"1\" colorSpace=\"custom\" customColorSpace=\"sRGB\"/>\n                        <constraints>\n                            <constraint firstItem=\"ewF-NN-AX5\" firstAttribute=\"centerY\" secondItem=\"8bC-Xf-vdC\" secondAttribute=\"centerY\" id=\"DvG-OV-XSx\"/>\n                            <constraint firstItem=\"ewF-NN-AX5\" firstAttribute=\"centerX\" secondItem=\"8bC-Xf-vdC\" secondAttribute=\"centerX\" id=\"QE6-XL-9yD\"/>\n                        </constraints>\n                    </view>\n                    <navigationItem key=\"navigationItem\" title=\"我是原生界面\" id=\"A0r-tB-PNQ\"/>\n                </viewController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"dkx-z0-nzr\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"20\" y=\"129\"/>\n        </scene>\n        <!--RN界面-->\n        <scene sceneID=\"blN-Cj-XZY\">\n            <objects>\n                <viewController id=\"uMO-xq-gw5\" customClass=\"RNViewController\" sceneMemberID=\"viewController\">\n                    <layoutGuides>\n                        <viewControllerLayoutGuide type=\"top\" id=\"xBa-QW-gat\"/>\n                        <viewControllerLayoutGuide type=\"bottom\" id=\"vP4-I2-cUk\"/>\n                    </layoutGuides>\n                    <view key=\"view\" contentMode=\"scaleToFill\" id=\"F5L-mW-jGp\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"375\" height=\"667\"/>\n                        <autoresizingMask key=\"autoresizingMask\" widthSizable=\"YES\" heightSizable=\"YES\"/>\n                        <color key=\"backgroundColor\" white=\"1\" alpha=\"1\" colorSpace=\"calibratedWhite\"/>\n                    </view>\n                    <navigationItem key=\"navigationItem\" title=\"RN界面\" id=\"8QR-M3-z3d\"/>\n                </viewController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"OGb-HK-HWZ\" userLabel=\"First Responder\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"764\" y=\"128\"/>\n        </scene>\n    </scenes>\n</document>\n```\n\n6. 添加以下内容到```Info.plist```以访问http：\n```\n    <key>NSAppTransportSecurity</key>\n    <!--See http://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/ -->\n    <dict>\n        <key>NSExceptionDomains</key>\n        <dict>\n            <key>localhost</key>\n            <dict>\n                <key>NSExceptionAllowsInsecureHTTPLoads</key>\n                <true/>\n            </dict>\n        </dict>\n    </dict>\n```\n\n7. 根目录下运行```npm start```和```react-native run-ios```\n","tags":["学习笔记"],"categories":["RectNative"]},{"title":"screen命令参考","url":"/2018/05/23/screen-cookbook/","content":"\n#screen常用命令\n\n- 在screen外面使用的命令\n\n| 命令                | 解释               |\n| :---                | :---             |\n| ```screen -ls```    | 查看所有screen会话 |\n| ```screen -S XXX``` | 创建署名screen会话 |\n| ```screen -r XXX``` | 恢复署名screen会话 |\n\n\n\n\n\n- 在screen里面使用的命令\n\n| 命令           | 解释               |\n| :---           | :---              |\n| ```C-a ?```    | 查看帮助           |\n| ```C-a S```    | 水平分割屏幕       |\n| ```C-a \\```    | 垂直分割屏幕       |\n| ```C-a c```    | 新建一个窗口       |\n| ```C-a n```    | 切换下一个窗口     |\n| ```C-a p```    | 切换上一个窗口     |\n| ```C-a 0..9``` | 切换到第0..9个窗口 |\n| ```C-a k```    | 杀死当前窗口       |\n| ```C-a \"```    | 查看所有窗口列表   |\n| ```C-a d```    | 暂时离开           |\n| ```C-a [```    | 进入拷贝回滚模式   |\n\n\n","tags":["学习笔记"],"categories":["Linux"]},{"title":"react-native troubleshooting","url":"/2018/05/21/rn-troubleshooting/","content":"\n- #### Common\n    \n    - ```error: bundling: NotFoundError: Cannot find entry file index.js in any of the roots: [\"/Users/zhenlei/Projects/rn/FunGuard\"]```\n    > 高版本使用index.js代替了index.ios.js和index.android.js了，所以请检查项目根目录下是否存在index.js\n\n\t- ```Could not connect to development server```\n\t搭建环境后运行项目出现：```Could not connect to development server```。\n\n\t然而使用浏览器打开[http://localhost:8081/index.ios.bundle?platform=ios&dev=true](http://localhost:8081/index.ios.bundle?platform=ios&dev=true)发现```packager```成功运行，\n浏览器中出现打包完成的内容，最后度娘告诉我，可能是机器对于localhost做了映射，于是将入口文件从```http://localhost:8081/index.ios.bundle?platform=ios&dev=true```改成```http://127.0.0.1:8081/index.ios.bundle?platform=ios&dev=true```解决问题。\n\n\n\n\n- #### IOS\n\n    -  运行```react-native run-ios```时，报错：```Print: Entry, \":CFBundleIdentifier\", Does Not Exist```\n\n    > 高版本的react-native依赖库问题。\n    > 解决方法：使用低版本的react-native ```react-native init MyApp --version 0.44.3```\n\n    - IOS不能使用http访问\n\n    > 在ios子目录中的Info.plist中最后添加\n    >```\n    ><key>NSAppTransportSecurity</key>\n    ><!--See http://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/ -->\n    ><dict>\n    >\t<key>NSExceptionDomains</key>\n    >\t<dict>\n    >\t\t<key>localhost</key>\n    >\t\t<dict>\n    >\t\t\t<key>NSExceptionAllowsInsecureHTTPLoads</key>\n    >\t\t\t<true/>\n    >\t\t</dict>\n    >\t</dict>\n    ></dict>\n    >```\n\n\n- #### Andorid\n\n    - ```SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable.```\n    > 在环境变量中添加ANDROID_HOME，例如```export ANDROID_HOME=/Users/zhenlei/Library/Android/sdk```\n\n\n\n\n\n","tags":["学习笔记"],"categories":["RectNative"]},{"title":"tar使用相对路径打包","url":"/2018/05/16/tar-cookbook-1/","content":"\n\n#### tar 使用相对路径打包\n```tar -zcvf XXXX.tgz -C /home/dstPath dstDirectory```\n> 其中```-C```参数是临时切换目录，即相对于谁打包\n\n\n\n","tags":["备忘录"],"categories":["Linux"]},{"title":"javascript date format","url":"/2018/05/15/date-format/","content":"\n- 使用prototype扩展\n```\n// 对Date的扩展，将 Date 转化为指定格式的String\n// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，\n// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)\n// 例子：\n// new Date().Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2018-05-15 10:18:00.013\n// new Date().Format(\"yyyy-M-d h:m:s.S\")      ==> 2018-5-15 10:18:0.01\nDate.prototype.Format = function (fmt) {\n    var o = {\n        \"M+\": this.getMonth() + 1, //月份\n        \"d+\": this.getDate(), //日\n        \"h+\": this.getHours(), //小时\n        \"m+\": this.getMinutes(), //分\n        \"s+\": this.getSeconds(), //秒\n        \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度\n        \"S\": this.getMilliseconds() //毫秒\n    };\n    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (var k in o)\n        if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n    return fmt;\n}\n```\n\n\n\n\n> 核心思想： 使用正则表达式（分组思想）测试格式格式字符串，用分组的长度(RegExp.$1.length：第一组的长度)来设置字符串长度(substr)。\n\n- 带星期的日期格式化\n```\n// (new Date()).pattern(\"yyyy-MM-dd E HH:mm:ss\") ==> 2018-05-15 二 10:18:00\n// (new Date()).pattern(\"yyyy-MM-dd EE hh:mm:ss\") ==> 2018-05-15 周二 10:18:00\n// (new Date()).pattern(\"yyyy-MM-dd EEE hh:mm:ss\") ==> 2018-05-15 星期二 10:18:00\nDate.prototype.pattern=function(fmt) {\n    var o = {\n    \"M+\" : this.getMonth()+1, //月份\n    \"d+\" : this.getDate(), //日\n    \"h+\" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时\n    \"H+\" : this.getHours(), //小时\n    \"m+\" : this.getMinutes(), //分\n    \"s+\" : this.getSeconds(), //秒\n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度\n    \"S\" : this.getMilliseconds() //毫秒\n    };\n    var week = {\n    \"0\" : \"/u65e5\",\n    \"1\" : \"/u4e00\",\n    \"2\" : \"/u4e8c\",\n    \"3\" : \"/u4e09\",\n    \"4\" : \"/u56db\",\n    \"5\" : \"/u4e94\",\n    \"6\" : \"/u516d\"\n    };\n    if(/(y+)/.test(fmt)){\n        fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length));\n    }\n    if(/(E+)/.test(fmt)){\n        fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length>1) ? (RegExp.$1.length>2 ? \"/u661f/u671f\" : \"/u5468\") : \"\")+week[this.getDay()+\"\"]);\n    }\n    for(var k in o){\n        if(new RegExp(\"(\"+ k +\")\").test(fmt)){\n            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));\n        }\n    }\n    return fmt;\n}\n```\n> 核心思想：基础同上；区别在于用了一个week保存星期一到星期日的unicode值，测试E的时候动态设置（二/周二/星期二）。\n\n##### 通常时间格式化函数都是通过正则表达式(主要是分组测试取长度)测试格式字符串来动态设置显示格式的。\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"javascript 获取页面、窗口大小","url":"/2018/05/15/dom-height/","content":"\n#### 获取窗口尺寸\n```\nvar windowWidth = Math.max(\n    document.documentElement.clientWidth,\n    window.innerWidth\n);\n\nvar windowHeight = Math.max(\n    document.documentElement.clientHeight,\n    window.innerHeight\n);\n```\n\n\n\n\n#### 获取页面尺寸\n```\nvar pageWidth = Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth\n);\n\nvar pageHeight = Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight\n);\n```\n\n详细解释：\n\n| 描述               | 代码                                      |\n| :-                 | :-                                        |\n| 网页可见区域宽     | document.body.clientWidth                 |\n| 网页可见区域高     | document.body.clientHeight                |\n| 网页可见区域宽     | document.body.offsetWidth (包括边线的宽)  |\n| 网页可见区域高     | document.body.offsetHeight (包括边线的高) |\n| 网页正文全文宽     | document.body.scrollWidth                 |\n| 网页正文全文高     | document.body.scrollHeight                |\n| 网页被卷去的高     | document.body.scrollTop                   |\n| 网页被卷去的左     | document.body.scrollLeft                  |\n| 网页正文部分上     | window.screenTop                          |\n| 网页正文部分左     | window.screenLeft                         |\n| 屏幕分辨率的高     | window.screen.height                      |\n| 屏幕分辨率的宽     | window.screen.width                       |\n| 屏幕可用工作区高度 | window.screen.availHeight                 |\n| 屏幕可用工作区宽度 | window.screen.availWidth                  |\n| 网页可见区域宽     | document.body.clientWidth                 |\n| 网页可见区域高     | document.body.clientHeight                |\n| 网页可见区域宽     | document.body.offsetWidth (包括边线的宽)  |\n| 网页可见区域高     | document.body.offsetHeight (包括边线的高) |\n| 网页正文全文宽     | document.body.scrollWidth                 |\n| 网页正文全文高     | document.body.scrollHeight                |\n| 网页被卷去的高     | document.body.scrollTop                   |\n| 网页被卷去的左     | document.body.scrollLeft                  |\n| 网页正文部分上     | window.screenTop                          |\n| 网页正文部分左     | window.screenLeft                         |\n| 屏幕分辨率的高     | window.screen.height                      |\n| 屏幕分辨率的宽     | window.screen.width                       |\n| 屏幕可用工作区高度 | window.screen.availHeight                 |\n| 屏幕可用工作区宽度 | window.screen.availWidth                  |\n| 网页可见区域宽     | document.body.clientWidth                 |\n| 网页可见区域高     | document.body.clientHeight                |\n| 网页可见区域宽     | document.body.offsetWidth (包括边线的宽)  |\n| 网页可见区域高     | document.body.offsetHeight (包括边线的高) |\n| 网页正文全文宽     | document.body.scrollWidth                 |\n| 网页正文全文高     | document.body.scrollHeight                |\n| 网页被卷去的高     | document.body.scrollTop                   |\n| 网页被卷去的左     | document.body.scrollLeft                  |\n| 网页正文部分上     | window.screenTop                          |\n| 网页正文部分左     | window.screenLeft                         |\n| 屏幕分辨率的高     | window.screen.height                      |\n| 屏幕分辨率的宽     | window.screen.width                       |\n| 屏幕可用工作区高度 | window.screen.availHeight                 |\n| 屏幕可用工作区宽度 | window.screen.availWidth                  |\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"firewall-cmd常用命令","url":"/2018/05/14/firewall-cookbook/","content":"\n- 允许端口访问\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\nfirewall-cmd --zone=public --add-port=22/tcp --permanent\n```\n\n- 禁止端口访问\n```\nfirewall-cmd --zone=public --remove-port=80/tcp --permanent\nfirewall-cmd --zone=public --remove-port=22/tcp --permanent\n```\n\n- 允许端口段访问\n```\nfirewall-cmd --zone=public --add-port=4400-4600/udp --permanent\nfirewall-cmd --zone=public --add-port=4400-4600/tcp --permanent\n```\n\n- 禁止端口段访问\n```\nfirewall-cmd --zone=public --remove-port=4400-4600/udp --permanent\nfirewall-cmd --zone=public --remove-port=4400-4600/tcp --permanent\n```\n\n- 开启防火墙\n```systemctl start firewalld.service```\n\n- 重启防火墙\n```\nfirewall-cmd --reload  或者   service firewalld restart\n```\n\n- 查看防火墙列表\n```\nfirewall-cmd --permanent --list-port\n```\n\n- 常规systemd操作\n```\nsystemd enable firewalld //开机自启动\nsystemd disable firewalld //禁止开机自启动\nsystemd start firewalld //开启\nsystemd stop firewalldA //停止\nsystemd status firewalld //查看状态\n```\n\n\n- centos下安装\n```\nyum install -y firewalld firewalld-config\n```\n\n- centos下```firewall-cmd --help```\n> ```\n> \n> Usage: firewall-cmd [OPTIONS...]\n> \n> General Options\n>   -h, --help           Prints a short help text and exists\n>   -V, --version        Print the version string of firewalld\n>   -q, --quiet          Do not print status messages\n> \n> Status Options\n>   --state              Return and print firewalld state\n>   --reload             Reload firewall and keep state information\n>   --complete-reload    Reload firewall and lose state information\n>   --runtime-to-permanent\n>                        Create permanent from runtime configuration\n> \n> Log Denied Options\n>   --get-log-denied     Print the log denied value\n>   --set-log-denied=<value>\n>                        Set log denied value\n> \n> Automatic Helpers Options\n>   --get-automatic-helpers\n>                        Print the automatic helpers value\n>   --set-automatic-helpers=<value>\n>                        Set automatic helpers value\n> \n> Permanent Options\n>   --permanent          Set an option permanently\n>                        Usable for options marked with [P]\n> \n> Zone Options\n>   --get-default-zone   Print default zone for connections and interfaces\n>   --set-default-zone=<zone>\n>                        Set default zone\n>   --get-active-zones   Print currently active zones\n>   --get-zones          Print predefined zones [P]\n>   --get-services       Print predefined services [P]\n>   --get-icmptypes      Print predefined icmptypes [P]\n>   --get-zone-of-interface=<interface>\n>                        Print name of the zone the interface is bound to [P]\n>   --get-zone-of-source=<source>[/<mask>]|<MAC>|ipset:<ipset>\n>                        Print name of the zone the source is bound to [P]\n>   --list-all-zones     List everything added for or enabled in all zones [P]\n>   --new-zone=<zone>    Add a new zone [P only]\n>   --new-zone-from-file=<filename> [--name=<zone>]\n>                        Add a new zone from file with optional name [P only]\n>   --delete-zone=<zone> Delete an existing zone [P only]\n>   --load-zone-defaults=<zone>\n>                        Load zone default settings [P only] [Z]\n>   --zone=<zone>        Use this zone to set or query options, else default zone\n>                        Usable for options marked with [Z]\n>   --get-target         Get the zone target [P only] [Z]\n>   --set-target=<target>\n>                        Set the zone target [P only] [Z]\n>   --info-zone=<zone>   Print information about a zone\n>   --path-zone=<zone>   Print file path of a zone [P only]\n> \n> IPSet Options\n>   --get-ipset-types    Print the supported ipset types\n>   --new-ipset=<ipset> --type=<ipset type> [--option=<key>[=<value>]]..\n>                        Add a new ipset [P only]\n>   --new-ipset-from-file=<filename> [--name=<ipset>]\n>                        Add a new ipset from file with optional name [P only]\n>   --delete-ipset=<ipset>\n>                        Delete an existing ipset [P only]\n>   --load-ipset-defaults=<ipset>\n>                        Load ipset default settings [P only]\n>   --info-ipset=<ipset> Print information about an ipset\n>   --path-ipset=<ipset> Print file path of an ipset [P only]\n>   --get-ipsets         Print predefined ipsets\n>   --ipset=<ipset> --set-description=<description>\n>                        Set new description to ipset [P only]\n>   --ipset=<ipset> --get-description\n>                        Print description for ipset [P only]\n>   --ipset=<ipset> --set-short=<description>\n>                        Set new short description to ipset [P only]\n>   --ipset=<ipset> --get-short\n>                        Print short description for ipset [P only]\n>   --ipset=<ipset> --add-entry=<entry>\n>                        Add a new entry to an ipset [P]\n>   --ipset=<ipset> --remove-entry=<entry>\n>                        Remove an entry from an ipset [P]\n>   --ipset=<ipset> --query-entry=<entry>\n>                        Return whether ipset has an entry [P]\n>   --ipset=<ipset> --get-entries\n>                        List entries of an ipset [P]\n>   --ipset=<ipset> --add-entries-from-file=<entry>\n>                        Add a new entries to an ipset [P]\n>   --ipset=<ipset> --remove-entries-from-file=<entry>\n>                        Remove entries from an ipset [P]\n> \n> IcmpType Options\n>   --new-icmptype=<icmptype>\n>                        Add a new icmptype [P only]\n>   --new-icmptype-from-file=<filename> [--name=<icmptype>]\n>                        Add a new icmptype from file with optional name [P only]\n>   --delete-icmptype=<icmptype>\n>                        Delete an existing icmptype [P only]\n>   --load-icmptype-defaults=<icmptype>\n>                        Load icmptype default settings [P only]\n>   --info-icmptype=<icmptype>\n>                        Print information about an icmptype\n>   --path-icmptype=<icmptype>\n>                        Print file path of an icmptype [P only]\n>   --icmptype=<icmptype> --set-description=<description>\n>                        Set new description to icmptype [P only]\n>   --icmptype=<icmptype> --get-description\n>                        Print description for icmptype [P only]\n>   --icmptype=<icmptype> --set-short=<description>\n>                        Set new short description to icmptype [P only]\n>   --icmptype=<icmptype> --get-short\n>                        Print short description for icmptype [P only]\n>   --icmptype=<icmptype> --add-destination=<ipv>\n>                        Enable destination for ipv in icmptype [P only]\n>   --icmptype=<icmptype> --remove-destination=<ipv>\n>                        Disable destination for ipv in icmptype [P only]\n>   --icmptype=<icmptype> --query-destination=<ipv>\n>                        Return whether destination ipv is enabled in icmptype [P only]\n>   --icmptype=<icmptype> --get-destinations\n>                        List destinations in icmptype [P only]\n> \n> Service Options\n>   --new-service=<service>\n>                        Add a new service [P only]\n>   --new-service-from-file=<filename> [--name=<service>]\n>                        Add a new service from file with optional name [P only]\n>   --delete-service=<service>\n>                        Delete an existing service [P only]\n>   --load-service-defaults=<service>\n>                        Load icmptype default settings [P only]\n>   --info-service=<service>\n>                        Print information about a service\n>   --path-service=<service>\n>                        Print file path of a service [P only]\n>   --service=<service> --set-description=<description>\n>                        Set new description to service [P only]\n>   --service=<service> --get-description\n>                        Print description for service [P only]\n>   --service=<service> --set-short=<description>\n>                        Set new short description to service [P only]\n>   --service=<service> --get-short\n>                        Print short description for service [P only]\n>   --service=<service> --add-port=<portid>[-<portid>]/<protocol>\n>                        Add a new port to service [P only]\n>   --service=<service> --remove-port=<portid>[-<portid>]/<protocol>\n>                        Remove a port from service [P only]\n>   --service=<service> --query-port=<portid>[-<portid>]/<protocol>\n>                        Return whether the port has been added for service [P only]\n>   --service=<service> --get-ports\n>                        List ports of service [P only]\n>   --service=<service> --add-protocol=<protocol>\n>                        Add a new protocol to service [P only]\n>   --service=<service> --remove-protocol=<protocol>\n>                        Remove a protocol from service [P only]\n>   --service=<service> --query-protocol=<protocol>\n>                        Return whether the protocol has been added for service [P only]\n>   --service=<service> --get-protocols\n>                        List protocols of service [P only]\n>   --service=<service> --add-source-port=<portid>[-<portid>]/<protocol>\n>                        Add a new source port to service [P only]\n>   --service=<service> --remove-source-port=<portid>[-<portid>]/<protocol>\n>                        Remove a source port from service [P only]\n>   --service=<service> --query-source-port=<portid>[-<portid>]/<protocol>\n>                        Return whether the source port has been added for service [P only]\n>   --service=<service> --get-source-ports\n>                        List source ports of service [P only]\n>   --service=<service> --add-module=<module>\n>                        Add a new module to service [P only]\n>   --service=<service> --remove-module=<module>\n>                        Remove a module from service [P only]\n>   --service=<service> --query-module=<module>\n>                        Return whether the module has been added for service [P only]\n>   --service=<service> --get-modules\n>                        List modules of service [P only]\n>   --service=<service> --set-destination=<ipv>:<address>[/<mask>]\n>                        Set destination for ipv to address in service [P only]\n>   --service=<service> --remove-destination=<ipv>\n>                        Disable destination for ipv i service [P only]\n>   --service=<service> --query-destination=<ipv>:<address>[/<mask>]\n>                        Return whether destination ipv is set for service [P only]\n>   --service=<service> --get-destinations\n>                        List destinations in service [P only]\n> \n> Options to Adapt and Query Zones\n>   --list-all           List everything added for or enabled in a zone [P] [Z]\n>   --list-services      List services added for a zone [P] [Z]\n>   --timeout=<timeval>  Enable an option for timeval time, where timeval is\n>                        a number followed by one of letters 's' or 'm' or 'h'\n>                        Usable for options marked with [T]\n>   --set-description=<description>\n>                        Set new description to zone [P only] [Z]\n>   --get-description    Print description for zone [P only] [Z]\n>   --set-short=<description>\n>                        Set new short description to zone [P only] [Z]\n>   --get-short          Print short description for zone [P only] [Z]\n>   --add-service=<service>\n>                        Add a service for a zone [P] [Z] [T]\n>   --remove-service=<service>\n>                        Remove a service from a zone [P] [Z]\n>   --query-service=<service>\n>                        Return whether service has been added for a zone [P] [Z]\n>   --list-ports         List ports added for a zone [P] [Z]\n>   --add-port=<portid>[-<portid>]/<protocol>\n>                        Add the port for a zone [P] [Z] [T]\n>   --remove-port=<portid>[-<portid>]/<protocol>\n>                        Remove the port from a zone [P] [Z]\n>   --query-port=<portid>[-<portid>]/<protocol>\n>                        Return whether the port has been added for zone [P] [Z]\n>   --list-protocols     List protocols added for a zone [P] [Z]\n>   --add-protocol=<protocol>\n>                        Add the protocol for a zone [P] [Z] [T]\n>   --remove-protocol=<protocol>\n>                        Remove the protocol from a zone [P] [Z]\n>   --query-protocol=<protocol>\n>                        Return whether the protocol has been added for zone [P] [Z]\n>   --list-source-ports  List source ports added for a zone [P] [Z]\n>   --add-source-port=<portid>[-<portid>]/<protocol>\n>                        Add the source port for a zone [P] [Z] [T]\n>   --remove-source-port=<portid>[-<portid>]/<protocol>\n>                        Remove the source port from a zone [P] [Z]\n>   --query-source-port=<portid>[-<portid>]/<protocol>\n>                        Return whether the source port has been added for zone [P] [Z]\n>   --list-icmp-blocks   List Internet ICMP type blocks added for a zone [P] [Z]\n>   --add-icmp-block=<icmptype>\n>                        Add an ICMP block for a zone [P] [Z] [T]\n>   --remove-icmp-block=<icmptype>\n>                        Remove the ICMP block from a zone [P] [Z]\n>   --query-icmp-block=<icmptype>\n>                        Return whether an ICMP block has been added for a zone\n>                        [P] [Z]\n>   --add-icmp-block-inversion\n>                        Enable inversion of icmp blocks for a zone [P] [Z]\n>   --remove-icmp-block-inversion\n>                        Disable inversion of icmp blocks for a zone [P] [Z]\n>   --query-icmp-block-inversion\n>                        Return whether inversion of icmp blocks has been enabled\n>                        for a zone [P] [Z]\n>   --list-forward-ports List IPv4 forward ports added for a zone [P] [Z]\n>   --add-forward-port=port=<portid>[-<portid>]:proto=<protocol>[:toport=<portid>[-<portid>]][:toaddr=<address>[/<mask>]]\n>                        Add the IPv4 forward port for a zone [P] [Z] [T]\n>   --remove-forward-port=port=<portid>[-<portid>]:proto=<protocol>[:toport=<portid>[-<portid>]][:toaddr=<address>[/<mask>]]\n>                        Remove the IPv4 forward port from a zone [P] [Z]\n>   --query-forward-port=port=<portid>[-<portid>]:proto=<protocol>[:toport=<portid>[-<portid>]][:toaddr=<address>[/<mask>]]\n>                        Return whether the IPv4 forward port has been added for\n>                        a zone [P] [Z]\n>   --add-masquerade     Enable IPv4 masquerade for a zone [P] [Z] [T]\n>   --remove-masquerade  Disable IPv4 masquerade for a zone [P] [Z]\n>   --query-masquerade   Return whether IPv4 masquerading has been enabled for a\n>                        zone [P] [Z]\n>   --list-rich-rules    List rich language rules added for a zone [P] [Z]\n>   --add-rich-rule=<rule>\n>                        Add rich language rule 'rule' for a zone [P] [Z] [T]\n>   --remove-rich-rule=<rule>\n>                        Remove rich language rule 'rule' from a zone [P] [Z]\n>   --query-rich-rule=<rule>\n>                        Return whether a rich language rule 'rule' has been\n>                        added for a zone [P] [Z]\n> \n> Options to Handle Bindings of Interfaces\n>   --list-interfaces    List interfaces that are bound to a zone [P] [Z]\n>   --add-interface=<interface>\n>                        Bind the <interface> to a zone [P] [Z]\n>   --change-interface=<interface>\n>                        Change zone the <interface> is bound to [Z]\n>   --query-interface=<interface>\n>                        Query whether <interface> is bound to a zone [P] [Z]\n>   --remove-interface=<interface>\n>                        Remove binding of <interface> from a zone [P] [Z]\n> \n> Options to Handle Bindings of Sources\n>   --list-sources       List sources that are bound to a zone [P] [Z]\n>   --add-source=<source>[/<mask>]|<MAC>|ipset:<ipset>\n>                        Bind the source to a zone [P] [Z]\n>   --change-source=<source>[/<mask>]|<MAC>|ipset:<ipset>\n>                        Change zone the source is bound to [Z]\n>   --query-source=<source>[/<mask>]|<MAC>|ipset:<ipset>\n>                        Query whether the source is bound to a zone [P] [Z]\n>   --remove-source=<source>[/<mask>]|<MAC>|ipset:<ipset>\n>                        Remove binding of the source from a zone [P] [Z]\n> \n> Helper Options\n>   --new-helper=<helper> --module=<module> [--family=<family>]\n>                        Add a new helper [P only]\n>   --new-helper-from-file=<filename> [--name=<helper>]\n>                        Add a new helper from file with optional name [P only]\n>   --delete-helper=<helper>\n>                        Delete an existing helper [P only]\n>   --load-helper-defaults=<helper>\n>                        Load helper default settings [P only]\n>   --info-helper=<helper> Print information about an helper\n>   --path-helper=<helper> Print file path of an helper [P only]\n>   --get-helpers         Print predefined helpers\n>   --helper=<helper> --set-description=<description>\n>                        Set new description to helper [P only]\n>   --helper=<helper> --get-description\n>                        Print description for helper [P only]\n>   --helper=<helper> --set-short=<description>\n>                        Set new short description to helper [P only]\n>   --helper=<helper> --get-short\n>                        Print short description for helper [P only]\n>   --helper=<helper> --add-port=<portid>[-<portid>]/<protocol>\n>                        Add a new port to helper [P only]\n>   --helper=<helper> --remove-port=<portid>[-<portid>]/<protocol>\n>                        Remove a port from helper [P only]\n>   --helper=<helper> --query-port=<portid>[-<portid>]/<protocol>\n>                        Return whether the port has been added for helper [P only]\n>   --helper=<helper> --get-ports\n>                        List ports of helper [P only]\n>   --helper=<helper> --set-module=<module>\n>                        Set module to helper [P only]\n>   --helper=<helper> --get-module\n>                        Get module from helper [P only]\n>   --helper=<helper> --set-family={ipv4|ipv6|}\n>                        Set family for helper [P only]\n>   --helper=<helper> --get-family\n>                        Get module from helper [P only]\n> \n> Direct Options\n>   --direct             First option for all direct options\n>   --get-all-chains\n>                        Get all chains [P]\n>   --get-chains {ipv4|ipv6|eb} <table>\n>                        Get all chains added to the table [P]\n>   --add-chain {ipv4|ipv6|eb} <table> <chain>\n>                        Add a new chain to the table [P]\n>   --remove-chain {ipv4|ipv6|eb} <table> <chain>\n>                        Remove the chain from the table [P]\n>   --query-chain {ipv4|ipv6|eb} <table> <chain>\n>                        Return whether the chain has been added to the table [P]\n>   --get-all-rules\n>                        Get all rules [P]\n>   --get-rules {ipv4|ipv6|eb} <table> <chain>\n>                        Get all rules added to chain in table [P]\n>   --add-rule {ipv4|ipv6|eb} <table> <chain> <priority> <arg>...\n>                        Add rule to chain in table [P]\n>   --remove-rule {ipv4|ipv6|eb} <table> <chain> <priority> <arg>...\n>                        Remove rule with priority from chain in table [P]\n>   --remove-rules {ipv4|ipv6|eb} <table> <chain>\n>                        Remove rules from chain in table [P]\n>   --query-rule {ipv4|ipv6|eb} <table> <chain> <priority> <arg>...\n>                        Return whether a rule with priority has been added to\n>                        chain in table [P]\n>   --passthrough {ipv4|ipv6|eb} <arg>...\n>                        Pass a command through (untracked by firewalld)\n>   --get-all-passthroughs\n>                        Get all tracked passthrough rules [P]\n>   --get-passthroughs {ipv4|ipv6|eb} <arg>...\n>                        Get tracked passthrough rules [P]\n>   --add-passthrough {ipv4|ipv6|eb} <arg>...\n>                        Add a new tracked passthrough rule [P]\n>   --remove-passthrough {ipv4|ipv6|eb} <arg>...\n>                        Remove a tracked passthrough rule [P]\n>   --query-passthrough {ipv4|ipv6|eb} <arg>...\n>                        Return whether the tracked passthrough rule has been\n>                        added [P]\n> \n> Lockdown Options\n>   --lockdown-on        Enable lockdown.\n>   --lockdown-off       Disable lockdown.\n>   --query-lockdown     Query whether lockdown is enabled\n> \n> Lockdown Whitelist Options\n>   --list-lockdown-whitelist-commands\n>                        List all command lines that are on the whitelist [P]\n>   --add-lockdown-whitelist-command=<command>\n>                        Add the command to the whitelist [P]\n>   --remove-lockdown-whitelist-command=<command>\n>                        Remove the command from the whitelist [P]\n>   --query-lockdown-whitelist-command=<command>\n>                        Query whether the command is on the whitelist [P]\n>   --list-lockdown-whitelist-contexts\n>                        List all contexts that are on the whitelist [P]\n>   --add-lockdown-whitelist-context=<context>\n>                        Add the context context to the whitelist [P]\n>   --remove-lockdown-whitelist-context=<context>\n>                        Remove the context from the whitelist [P]\n>   --query-lockdown-whitelist-context=<context>\n>                        Query whether the context is on the whitelist [P]\n>   --list-lockdown-whitelist-uids\n>                        List all user ids that are on the whitelist [P]\n>   --add-lockdown-whitelist-uid=<uid>\n>                        Add the user id uid to the whitelist [P]\n>   --remove-lockdown-whitelist-uid=<uid>\n>                        Remove the user id uid from the whitelist [P]\n>   --query-lockdown-whitelist-uid=<uid>\n>                        Query whether the user id uid is on the whitelist [P]\n>   --list-lockdown-whitelist-users\n>                        List all user names that are on the whitelist [P]\n>   --add-lockdown-whitelist-user=<user>\n>                        Add the user name user to the whitelist [P]\n>   --remove-lockdown-whitelist-user=<user>\n>                        Remove the user name user from the whitelist [P]\n>   --query-lockdown-whitelist-user=<user>\n>                        Query whether the user name user is on the whitelist [P]\n> \n> Panic Options\n>   --panic-on           Enable panic mode\n>   --panic-off          Disable panic mode\n>   --query-panic        Query whether panic mode is enabled\n> ```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"javascript检测是否存在属性","url":"/2018/05/14/for-in/","content":"\n- in运算符\n```\nlet obj = {\"name\": \"asdf\",\"age\": \"123\"}\nalert('name' in obj); // --> ture\nalert('toString' in obj); // --> ture\n```\n\n\n\n> in能检测到原型链的属性，但for in却不行。\n>> ```\n    for(x in obj)\n        console.log(x)\n        // name\n        // age\n    ```\n\n- hasOwnProperty方法\n```\nlet obj = {\"name\": \"asdf\",\"age\": \"123\"}\nobj.hasOwnProperty('name'); // --> true\nobj.hasOwnProperty('toString'); // --> false\n```\n\n> 原型链上继承过来的属性(如：toString)无法通过hasOwnProperty检测到，返回false。\n\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"javascript积累","url":"/2018/05/10/javascript-memo/","content":"\n- ### replace\n\n```\nreplace(/(^\\s*)|(\\s*$)/g, \"\")\n```\n> example: trim()\n\n```\nfunction trim(){\n    replace(/(^\\s*)|(\\s*$)/g, \"\")\n}\n```\n\n- ### keycode\n\n```\nfunction forEnter(e){\n    var keyCode = e.keyCode || e.which || e.charCode;\n    var ctrlKey = e.ctrlKey || e.metaKey;\n    if(ctrlKey && keyCode == 13) { //ctrl + enter || meta + enter\n        //do something\n    }\n    return true;\n}\n```\n\n- ### 添加监听，动态修改class\n\n```\nechoItem.addEventListener('mouseenter', function(event) {\n    echoItem.classList.add('echo-item-mouseon');\n}, true)\nechoItem.addEventListener('mouseout', function(event) {\n    echoItem.classList.remove('echo-item-mouseon');\n}, true)\n```\n\n- ### css\n    - #### 鼠标移入效果\n    \n    ```\n    .echo-item-indicator-resend{\n        display: -webkit-flex; /* Safari */\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        opacity: 0.3;\n        background-image:url('./img/repeated.webp');\n        background-repeat:no-repeat;\n        background-position:center;\n    }\n    ```\n\n    ```\n    .echo-item-indicator-resend:hover {\n        background: transparent;\n        opacity: 1;\n        background-image:url('./img/repeated.webp');\n        background-repeat:no-repeat;\n        background-position:center;\n    }\n    ```\n\n    - #### css动画\n\n    ```\n    .echo-item-indicator-slidein {\n        -moz-animation-duration: 0.5s;\n        -webkit-animation-duration: 0.5s;\n        animation-duration: 0.5s;\n        -moz-animation-name: echo-item-indicator-slidein;\n        -webkit-animation-name: echo-item-indicator-slidein;\n        animation-name: echo-item-indicator-slidein;\n        margin-left: 0%;\n    }\n    ```\n    关键帧\n    ```\n    @-moz-keyframes echo-item-indicator-slidein {\n        from {\n            margin-left: 100%;\n        }\n        to {\n            margin-left: 0%;\n        }\n    }\n\n    @-webkit-keyframes echo-item-indicator-slidein {\n        from {\n            margin-left: 100%;\n        }\n        to {\n            margin-left: 0%;\n        }\n    }\n\n    @keyframes echo-item-indicator-slidein {\n        from {\n            margin-left: 100%;\n        }\n        to {\n            margin-right: 0%;\n        }\n    }\n```\n","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"centos7设置静态IP","url":"/2018/05/10/static-ip-memo/","content":"\n##### 1. 修改配置文件\n原始dhcp配置例子```cat /etc/sysconfig/network-scripts/ifcfg-XXX```：\n\n```\nTYPE=\"Ethernet\"\nPROXY_METHOD=\"none\"\nBROWSER_ONLY=\"no\"\nBOOTPROTO=\"dhcp\"\nDEFROUTE=\"yes\"\nIPV4_FAILURE_FATAL=\"no\"\nIPV6INIT=\"yes\"\nIPV6_AUTOCONF=\"yes\"\nIPV6_DEFROUTE=\"yes\"\nIPV6_FAILURE_FATAL=\"no\"\nIPV6_ADDR_GEN_MODE=\"stable-privacy\"\nNAME=\"ens192\"\nUUID=\"9c7f61e1-4671-4dd0-9bd2-ece2ecfd722e\"\nDEVICE=\"ens192\"\nONBOOT=\"yes\"\nIPADDR=\"192.168.1.155\"\nPREFIX=\"24\"\nIPV6_PRIVACY=\"no\"\n```\n修改后的配置文件：\n```\nTYPE=\"Ethernet\"\nPROXY_METHOD=\"none\"\nBROWSER_ONLY=\"no\"\nBOOTPROTO=\"static\" #修改为static\nDEFROUTE=\"yes\"\nIPV4_FAILURE_FATAL=\"no\"\nIPV6INIT=\"yes\"\nIPV6_AUTOCONF=\"yes\"\nIPV6_DEFROUTE=\"yes\"\nIPV6_FAILURE_FATAL=\"no\"\nIPV6_ADDR_GEN_MODE=\"stable-privacy\"\nNAME=\"ens192\"\nUUID=\"66e324e0-daa8-4b31-a837-1f2f412be9d8\"\nDEVICE=\"ens192\"\nONBOOT=\"yes\"\nIPADDR=192.168.1.150 #静态IP\nGATEWAY=192.168.1.1 #默认网关\nNETMASK=255.255.255.0 #子网掩码\nDNS1=192.168.1.1 #DNS\n```\n\n##### 2. 重启network服务\n\n执行命令: ```service network restart```\n\n##### 3. 检查ip\n\n执行命令: ```ifconfig -a```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"websocket API","url":"/2018/05/10/websocket/","content":"\n- 创建websocket\n```\nvar ws = new WebSocket('ws://localhost:8888/ws');\n```\n\n- websocket相关属性\n    - readyState 属性返回当前实例的状态。一共四种：\n\n    | 状态       | 值  | 描述                 |\n    | :-:        | :-: | :-                   |\n    | CONNECTING | 0   | 正在连接中           |\n    | OPEN       | 1   | 连接成功，可以通信了 |\n    | CLOSING    | 2   | 正在关闭中           |\n    | CLOSED     | 3   | 已经关闭             |\n\n\n    > example:\n    ```\n    switch (ws.readyState) {\n        case WebSocket.CONNECTING:\n            // do something\n            break;\n        case WebSocket.OPEN:\n            // do something\n            break;\n        case WebSocket.CLOSING:\n            // do something\n            break;\n        case WebSocket.CLOSED:\n            // do something\n            break;\n        default:\n            // do something\n            break;\n    }\n    ```\n\n    - onopen 属性指定开启后的回调函数\n\n    > example:\n    ```\n    ws.onopen = function(evt) {\n        console.log('Connection open ...');\n    };\n    ```\n\n    - onclose 属性指定关闭后的回调函数\n\n    > example:\n    ```\n    ws.onclose = function(evt) {\n        console.log('Connection closed.');\n    };\n    ```\n\n    - onerror 属性指定关闭后的回调函数\n\n    > example:\n    ```\n    ws.onerror = function(evt) {\n        console.log('Connection error.');\n    };\n    ```\n\n    - onmessage 属性指定收到消息后的回调函数\n\n    > example:\n    ```\n    ws.onmessage = function(evt) {\n        console.log( 'Received Message: ' + evt.data);\n    };\n    ```\n\n- websocket的相关方法\n    - send() 方法用于向服务器发送消息。\n    发送文本\n\n    > ```ws.send('your message');```\n\n    发送Blob\n\n    > ```\n        var file = document\n          .querySelector('input[type=\"file\"]')\n          .files[0];\n        ws.send(file);\n    ```\n","tags":["学习笔记"],"categories":["Develop"]},{"title":"更换默认sh为zsh","url":"/2018/05/10/zsh-memo/","content":"### 1. 检查是否安装zsh\n\n执行命令: ```whereis zsh```\n如果查找到代表已经安装，否则请先安装zsh，具体安装方法请查阅各自发行版\n\n| 发行版| 安装命令|\n| :-: | :-: |\n| archlinux | ```pacman -S zsh``` |\n| centos | ```yum -y install zsh``` |\n| debain | ```apt install zsh``` |\n| other | 请从源码安装 |\n\n### 2. 更新sh\n\n执行命令: ```chsh -s /bin/zsh jinelei```\n\n### 3. 使用oh my zsh [Optional]\n\n执行命令: ```sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"```\n\n> 更多请参考[oh my zsh](http://ohmyz.sh/)\n\n### 快捷命令:\n```sudo yum -y install zsh && chsh -s /bin/zsh jinelei && sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"eclipse备忘录","url":"/2017/12/07/memo-eclipse-config/","content":"\n1. #### eclipse添加mybatis generator插件\n\n点击 help -> marketplace -> 搜索mybatis generator -> 点击安装。\n\n2. #### eclipse添加spring插件\n\n打开网站 http://spring.io/tools/sts/all，找到Update Sites(在线安装)或者Update Site Archives(离线安装)，选择自己的版本的url，将其添加到eclipse的在线安装，并安装。\n\n##### mybatis genertor 配置\n\n1. 添加maven插件\n```\n<plugin>  \n    <groupId>org.mybatis.generator</groupId>  \n    <artifactId>mybatis-generator-maven-plugin</artifactId>  \n    <version>1.3.2</version>  \n    <configuration>  \n        <verbose>true</verbose>  \n        <overwrite>true</overwrite>  \n    </configuration>  \n</plugin> \n```\n\n2. 添加generatorConfig.properties文件\n```\ndrive.class.path=/home/jinelei/.m2/repository/mysql/mysql-connector-java/5.1.44/mysql-connector-java-5.1.44.jar\n   \njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/catfish?useUnicode=true&characterEncoding=utf-8\njdbc.username=testname\njdbc.password=testpassword\n\nmodel.package=cn.jinelei.catfish.model\ndao.package=cn.jinelei.catfish.dao\nxml.mapper.package=/mybatis/mappers\ntarget.project=src/main/java\nresources.target.project=src/main/resources\n```\n\n\n\n3. 添加generatorConfig.xml文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE generatorConfiguration  \nPUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"  \n\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\n<generatorConfiguration>\n\t<!-- 配置文件路径 -->\n\t<properties resource=\"generatorConfig.properties\" />\n\t<!--数据库驱动包路径 -->\n\t<classPathEntry location=\"${drive.class.path}\" />\n\n\t<context id=\"MySQLTables\" targetRuntime=\"MyBatis3\">\n\t\t<!--关闭注释 -->\n\t\t<commentGenerator>\n\t\t\t<property name=\"suppressDate\" value=\"true\" />\n\t\t\t<property name=\"suppressAllComments\" value=\"true\" />\n\t\t</commentGenerator>\n\n\t\t<!--数据库连接信息 -->\n\t\t<jdbcConnection driverClass=\"${jdbc.driver}\"\n\t\t\tconnectionURL=\"${jdbc.url}\" userId=\"${jdbc.username}\" password=\"${jdbc.password}\">\n\t\t</jdbcConnection>\n\n\t\t<!--生成的model 包路径 -->\n\t\t<javaModelGenerator targetPackage=\"${model.package}\"\n\t\t\ttargetProject=\"${target.project}\">\n\t\t\t<property name=\"enableSubPackages\" value=\"ture\" />\n\t\t\t<property name=\"trimStrings\" value=\"true\" />\n\t\t</javaModelGenerator>\n\n\t\t<!--生成xml mapper文件 路径 -->\n\t\t<sqlMapGenerator targetPackage=\"${xml.mapper.package}\"\n\t\t\ttargetProject=\"${resources.target.project}\">\n\t\t\t<property name=\"enableSubPackages\" value=\"ture\" />\n\t\t</sqlMapGenerator>\n\n\t\t<!-- 生成的Dao接口 的包路径 -->\n\t\t<javaClientGenerator type=\"XMLMAPPER\"\n\t\t\ttargetPackage=\"${dao.package}\" targetProject=\"${target.project}\">\n\t\t\t<property name=\"enableSubPackages\" value=\"ture\" />\n\t\t</javaClientGenerator>\n\n\t\t<!--对应数据库表名 -->\n\t\t<table tableName=\"t_account\" domainObjectName=\"Account\"\n\t\t\tenableCountByExample=\"false\" enableDeleteByExample=\"false\"\n\t\t\tenableSelectByExample=\"false\" enableUpdateByExample=\"false\">\n\n\t\t</table>\n\t</context>\n</generatorConfiguration>\n```\n\n3. 添加Run Configurations, Goals中填写：\n```\nmybatis-generator:generate\n```\n","tags":["学习笔记"],"categories":["Java"]},{"title":"centos7下编译nginx","url":"/2017/12/06/centos-nginx-memo/","content":"\n- centos7下编译nginx遇到的问题\n```\n./configure: error: the HTTP rewrite module requires the PCRE library.\nYou can either disable the module by using --without-http_rewrite_module\noption, or install the PCRE library into the system, or build the PCRE library\nstatically from the source with nginx by using --with-pcre=<path> option.\n```\n\n解决办法\n```\nyum -y install pcre-devel\n```\n\n```\n./configure: error: the HTTP gzip module requires the zlib library.\nYou can either disable the module by using --without-http_gzip_module\noption, or install the zlib library into the system, or build the zlib library\nstatically from the source with nginx by using --with-zlib=<path> option.\n```\n解决办法\n```\nyum install -y zlib-devel\n```\n\n- nginx设置代理转发，解决微信头像跨域问题\n```\nlocation ^~ /wechat_image/ {\n  add_header 'Access-Control-Allow-Origin' \"$http_origin\" always;\n  add_header 'Access-Control-Allow-Credentials' 'true' always;\n  add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;\n  add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-   Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;\n  proxy_pass http://wx.qlogo.cn/;\n}\n```\n> 访问的时候将http://wx.qlogo.cn/XXX/XXX.XXX替换成http://${nginx_name}/wechat_image/XXX/XXX.XXX\n\n```\n./configure --prefix=/etc/nginx \\\n    --sbin-path=/usr/sbin/nginx \\\n    --conf-path=/etc/nginx/nginx.conf \\\n    --error-log-path=/var/log/nginx/error.log \\\n    --http-log-path=/var/log/nginx/access.log \\\n    --pid-path=/var/run/nginx.pid \\\n    --lock-path=/var/run/nginx.lock \\\n    --http-client-body-temp-path=/var/cache/nginx/client_temp \\\n    --http-proxy-temp-path=/var/cache/nginx/proxy_temp \\\n    --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \\\n    --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \\\n    --http-scgi-temp-path=/var/cache/nginx/scgi_temp \\\n    --with-http_realip_module \\\n    --with-http_addition_module \\\n    --with-http_sub_module \\\n    --with-http_dav_module \\\n    --with-http_flv_module \\\n    --with-http_mp4_module \\\n    --with-http_gunzip_module \\\n    --with-http_gzip_static_module \\\n    --with-http_random_index_module \\\n    --with-http_secure_link_module \\\n    --with-http_stub_status_module \\\n    --with-http_auth_request_module \\\n    --with-threads \\\n    --with-stream \\\n    --with-http_slice_module \\\n    --with-mail \\\n    --with-file-aio \\\n    --with-http_v2_module \\\n    --with-mail_ssl_module \\\n    --with-http_ssl_module \\\n    --with-stream_ssl_module \\\n    --with-openssl=/usr/local/openssl\\\n```\n","tags":["备忘录"],"categories":["Linux","Nginx"]},{"title":"hibernate.properties备忘录","url":"/2017/10/28/hibernate/","content":"\n##### jdbc属性\n\n|             属性名                    |       用途        |             oracle示例               | \n| ----------------------------------    | --------------    | ------------------------------------ |\n| hibernate.connection.driver_class     | jdbc驱动类        | oracle.jdbc.driver.OracleDriver      |\n| hibernate.connection.url              | jdbc URL          | jdbc:oracle:thin:@172.17.0.1:1521:XE |\n| hibernate.connection.username         | 数据库用户名      | system                               |\n| hibernate.connection.password         | 数据库密码        | oracle                               |\n| hibernate.connection.pool_size        | 连接池容量上限    | 1                                    |\n\n##### hibernate 数据源属性\n\n|             属性名                    |       用途                     |      oracle示例           | \n| ----------------------------------    | --------------                 | ------------------------- |\n|hibernate.connection.datasource\t    | 数据源JNDI名字                 |                           |\n|hibernate.jndi.url\t                    | JNDI提供者的URL                |                           | \n|hibernate.jndi.class\t                | JNDI InitialContextFactory类   |                           |\n|hibernate.connection.username\t        | 数据库用户                     |                           |\n|hibernate.connection.password\t        | 数据库用户密码                 |                           |\n\n\n##### 可选的配置属性\n\n|             属性名                    |       用途                     |      oracle示例           | \n| ----------------------------------    | --------------                 | ------------------------- |\n|hibernate.dialect|\t一个Hibernate Dialect类名允许Hibernate针对特定的关系数据库生成优化的SQL. |取值 full.classname.of.Dialect\n|hibernate.show_sql|\t输出所有SQL语句到控制台. 有一个另外的选择是把org.hibernate.SQL这个log category设为debug。 |eg. true / false\n|hibernate.format_sql|\t在log和console中打印出更漂亮的SQL。 |取值 true / false\n|hibernate.default_schema|\t在生成的SQL中, 将给定的schema/tablespace附加于非全限定名的表名上. |取值 SCHEMA_NAME\n|hibernate.default_catalog|\t在生成的SQL中, 将给定的catalog附加于非全限定名的表名上. |取值 CATALOG_NAME\n|hibernate.session_factory_name|\tSessionFactory创建后，将自动使用这个名字绑定到JNDI中. |取值 jndi/composite/name\n|hibernate.max_fetch_depth|\t为单向关联(一对一, 多对一)的外连接抓取（outer join fetch）树设置最大深度. 值为0意味着将关闭默认的外连接抓取. |取值 建议在0到3之间取值\n|hibernate.default_batch_fetch_size|\t为Hibernate关联的批量抓取设置默认数量. |取值 建议的取值为4, 8, 和16\n|hibernate.default_entity_mode|\t为由这个SessionFactory打开的所有Session指定默认的实体表现模式. |取值 dynamic-map, dom4j, pojo\n|hibernate.order_updates|\t强制Hibernate按照被更新数据的主键，为SQL更新排序。这么做将减少在高并发系统中事务的死锁。 |取值 true / false\n|hibernate.generate_statistics|\t如果开启, Hibernate将收集有助于性能调节的统计数据. |取值 true / false\n|hibernate.use_identifer_rollback|\t如果开启, 在对象被删除时生成的标识属性将被重设为默认值. |取值 true / false\n|hibernate.use_sql_comments|\t如果开启, Hibernate将在SQL中生成有助于调试的注释信息, 默认值为false. |取值 true / false\n\n####  Hibernate JDBC和连接(connection)属性\n\n|             属性名                    |       用途                     |      oracle示例           | \n| ----------------------------------    | --------------                 | ------------------------- |\n|hibernate.jdbc.fetch_size |\t非零值，指定JDBC抓取数量的大小 (调用Statement.setFetchSize()).\n|hibernate.jdbc.batch_size|\t非零值，允许Hibernate使用JDBC2的批量更新. |取值 建议取5到30之间的值\n|hibernate.jdbc.batch_versioned_data|\t如果你想让你的JDBC驱动从executeBatch()返回正确的行计数 , 那么将此属性设为true(开启这个选项通常是安全的). 同时，Hibernate将为自动版本化的数据使用批量DML. 默认值为false. |eg. true / false|\n|hibernate.jdbc.factory_class|\t选择一个自定义的Batcher. 多数应用程序不需要这个配置属性. |eg. classname.of.Batcher|\n|hibernate.jdbc.use_scrollable_resultset|\t允许Hibernate使用JDBC2的可滚动结果集. 只有在使用用户提供的JDBC连接时，这个选项才是必要的, 否则Hibernate会使用连接的元数据. |取值 true / false|\n|hibernate.jdbc.use_streams_for_binary|\t在JDBC读写binary (二进制)或serializable (可序列化) 的类型时使用流(stream)(系统级属性). |取值 true / false|\n|hibernate.jdbc.use_get_generated_keys|\t在数据插入数据库之后，允许使用JDBC3 PreparedStatement.getGeneratedKeys() 来获取数据库生成的key(键)。需要JDBC3+驱动和JRE1.4+, 如果你的数据库驱动在使用Hibernate的标 识生成器时遇到问题，请将此值设为false. 默认情况下将使用连接的元数据来判定驱动的能力. |取值 true/false|\n|hibernate.connection.provider_class|\t自定义ConnectionProvider的类名, 此类用来向Hibernate提供JDBC连接. |取值 classname.of.ConnectionProvider|\n|hibernate.connection.isolation|\t设置JDBC事务隔离级别. 查看java.sql.Connection来了解各个值的具体意义, 但请注意多数数据库都不支持所有的隔离级别. |取值 1, 2, 4, 8|\n|hibernate.connection.autocommit|\t允许被缓存的JDBC连接开启自动提交(autocommit) (不建议). |取值 true / false|\n|hibernate.connection.release_mode|\t指定Hibernate在何时释放JDBC连接. 默认情况下,直到Session被显式关闭或被断开连接时,才会释放JDBC连接. 对于应用程序服务器的JTA数据源, 你应当使用after_statement, 这样在每次JDBC调用后，都会主动的释放连接. 对于非JTA的连接, 使用after_transaction在每个事务结束时释放连接是合理的. auto将为JTA和CMT事务策略选择after_statement, 为JDBC事务策略选择after_transaction. |取值 on_close | after_transaction | after_statement | auto\n|hibernate.connection.`<propertyName>`|\t将JDBC属性propertyName传递到DriverManager.getConnection()中去.\n|hibernate.jndi.`<propertyName>`|\t将属性propertyName传递到JNDI InitialContextFactory中去.\n\n\n#### Hibernate 缓冲属性\n\n|             属性名                    |       用途                     |      oracle示例           | \n| ----------------------------------    | --------------                 | ------------------------- |\n|hibernate.cache.provider_class|\t自定义的CacheProvider的类名. |取值 classname.of.CacheProvider|\n|hibernate.cache.use_minimal_puts|\t以频繁的读操作为代价, 优化二级缓存来最小化写操作. 在Hibernate3中，这个设置对的集群缓存非常有用, 对集群缓存的实现而言，默认是开启的. |取值 true/false|\n|hibernate.cache.use_query_cache|\t允许查询缓存, 个别查询仍然需要被设置为可缓存的. |取值 true/false|\n|hibernate.cache.use_second_level_cache|\t能用来完全禁止使用二级缓存. 对那些在类的映射定义中指定<cache>的类，会默认开启二级缓存. |取值 true/false|\n|hibernate.cache.query_cache_factory|\t自定义实现QueryCache接口的类名, 默认为内建的StandardQueryCache. |取值 classname.of.QueryCache|\n|hibernate.cache.region_prefix|\t二级缓存区域名的前缀. |取值 prefix|\n|hibernate.cache.use_structured_entries|\t强制Hibernate以更人性化的格式将数据存入二级缓存. |取值 true/false|\n\n\n#### Hibernate 事务属性\n\n|             属性名                    |       用途                     |      oracle示例           | \n| ----------------------------------    | --------------                 | ------------------------- |\n|hibernate.transaction.factory_class|\t一个TransactionFactory的类名, 用于Hibernate Transaction API (默认为JDBCTransactionFactory). |取值 classname.of.TransactionFactory|\n|jta.UserTransaction|\t一个JNDI名字，被JTATransactionFactory用来从应用服务器获取JTA UserTransaction. |取值 jndi/composite/name|\n|hibernate.transaction.manager_lookup_class|\t一个TransactionManagerLookup的类名 - 当使用JVM级缓存，或在JTA环境中使用hilo生成器的时候需要该类. |取值 classname.of.TransactionManagerLookup|\n|hibernate.transaction.flush_before_completion|\t如果开启, session在事务完成后将被自动清洗(flush)。 现在更好的方法是使用自动session上下文管理。|取值 true / false\n|hibernate.transaction.auto_close_session|\t如果开启, session在事务完成后将被自动关闭。 现在更好的方法是使用自动session上下文管理。 |取值 true / false|\n\n\n\n#### 方言\n\n|             属性名                    |       用途                     |\n| ----------------------------------    | --------------                 |\n|DB2|\torg.hibernate.dialect.DB2Dialect\n|DB2| AS/400\torg.hibernate.dialect.DB2400Dialect\n|DB2| OS390\torg.hibernate.dialect.DB2390Dialect\n|PostgreSQL|\torg.hibernate.dialect.PostgreSQLDialect\n|MySQL|\torg.hibernate.dialect.MySQLDialect\n|MySQL| with InnoDB\torg.hibernate.dialect.MySQLInnoDBDialect\n|MySQL| with MyISAM\torg.hibernate.dialect.MySQLMyISAMDialect\n|Oracle| (any version)\torg.hibernate.dialect.OracleDialect\n|Oracle| 9i/10g\torg.hibernate.dialect.Oracle9Dialect\n|Sybase|\torg.hibernate.dialect.SybaseDialect\n|Sybase Anywhere|\torg.hibernate.dialect.SybaseAnywhereDialect\n|Microsoft SQL Server|\torg.hibernate.dialect.SQLServerDialect\n|SAP DB|\torg.hibernate.dialect.SAPDBDialect\n|Informix|\torg.hibernate.dialect.InformixDialect\n|HypersonicSQL|\torg.hibernate.dialect.HSQLDialect\n|Ingres|\torg.hibernate.dialect.IngresDialect\n|Progress|\torg.hibernate.dialect.ProgressDialect\n|Mckoi SQL\t|org.hibernate.dialect.MckoiDialect\n|Interbase|\torg.hibernate.dialect.InterbaseDialect\n|Pointbase|\torg.hibernate.dialect.PointbaseDialect\n|FrontBase|\torg.hibernate.dialect.FrontbaseDialect\n|Firebird|\torg.hibernate.dialect.FirebirdDialect\n\n#### 其他属性\n\n|             属性名                    |       用途                     |\n| ----------------------------------    | --------------                 |\n|hibernate.current_session_context_class|\t为\"当前\" Session指定一个(自定义的)策略。 |eg. jta / thread / custom.Class\n|hibernate.query.factory_class|\t选择HQL解析器的实现. |取值 org.hibernate.hql.ast.ASTQueryTranslatorFactory or org.hibernate.hql.classic.ClassicQueryTranslatorFactory\n|hibernate.query.substitutions|\t将Hibernate查询中的符号映射到SQL查询中的符号 (符号可能是函数名或常量名字). |取值 hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC\n|hibernate.hbm2ddl.auto|\t在SessionFactory创建时，自动检查数据库结构，或者将数据库schema的DDL导出到数据库. 使用 create-drop时,在显式关闭SessionFactory时，将drop掉数据库schema. |取值 validate / update / create / create-drop\n|hibernate.cglib.use_reflection_optimizer|\t开启CGLIB来替代运行时反射机制(系统级属性). 反射机制有时在除错时比较有用. 注意即使关闭这个优化, Hibernate还是需要CGLIB. 你不能在hibernate.cfg.xml中设置此属性. |取值 true / false\n","tags":["学习笔记"],"categories":["Java","Hibernate"]},{"title":"systemd备忘","url":"/2017/10/19/systemd-cookbook/","content":"\n\n####  结构\nSystemd服务分为三个部分，控制单元(unit)的定义、服务(service)的定义、安装部分。\n\n####  控制单元\n\n启动Shadowsocks单元\n\n```\n[Unit]\nDescription=Shadowsocks\n\n[Service]\nType=forking\nExecStart=/usr/bin/sslocal -c /etc/shadowsocks.json -d start\nExecStop=/usr/bin/sslocal -c /etc/shadowsocks.json -d stop\nStandardError=null\n\n[Install]\nWantedBy=multi-user.target\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"firefox设置缩放","url":"/2017/10/13/firefox-config/","content":"\n设置firefox缩放比例\n\n1. 在firefox中输入about:config\n\n2. 搜索关键字layout.css.devPixelsPerPx\n\n3. 设置相应的值：1.1表示110%\n","tags":["备忘录"],"categories":["Linux"]},{"title":"linux修改按键映射","url":"/2017/10/13/xmodmap-memo/","content":"\n1. xmodmap\n\n参考[archlinux wiki](https://wiki.archlinux.org/index.php/Xmodmap)\n\n将CapsLock映射为Ctrl\n\nxmodmap脚本样例:\n\n```\nclear lock\nclear control\nadd control = Caps_Lock Control_L Control_R\nkeycode 66 = Control_L Caps_Lock NoSymbol NoSymbol\n```\n\n2. xorg 参数\n\nXKbOptions参数参考/usr/share/X11/xkb/rulesbase.lst\n\n新建/etc/X11/xorg.conf.d/00-keyboard.conf\n\n```\n# Read and parsed by systemd-localed. It's probably wise not to edit this file\n# manually too freely.\n#Option \"XKbOptions\" \"grp:alt_caps_toggle,ctrl:swapcap\"\n#Option \"XKbOptions\" \"caps:ctrl_modifier\"\nSection \"InputClass\"\n    Identifier \"system-keyboard\"\n    Option \"XKbOptions\" \"ctrl:nocaps\"\n    MatchIsKeyboard \"on\"\nEndSection\n```\n","tags":["备忘录"],"categories":["Linux"]},{"title":"类加载概述及初始化条件","url":"/2017/08/02/learn-jvm-chapter7.1/","content":"\n####  概述\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转焊接西和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。  \n\n在Java中，类型的加载和连接过程都是在程序运行期间完成的，这样虽然会增加一些性能开销，却能为Java应用程序提高灵活性。  \n\n#### 类加载的时机  \n类从被加载到虚拟机内存开始，到卸载出内存位置，它的整个生命周期包括了：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）和卸载（unloading）七个阶段。其中验证、准备和解析三个部分被称为链接（linking）。  \n> 其中加载、验证、准备、初始化和卸载这五个阶段是顺序确定的。而解析阶段则是不确定的：它在某些情况下可以再初始化阶段之后在开始，这是为了支持Java语言的运行时绑定（动态绑定或晚期绑定）。 而且这些阶段通常是互相交叉的混合式进行的。\n\n---\n\n#### 类的初始化\n\n虚拟机规范严格规定了有且只有四种情况必须对类进行初始化（而加载、验证、准备需要先开始）：\n1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有被初始化，则进行初始化。这4条指令的典型场景是：使用new实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、已在调用一个类的静态方法的时候。\n2. 使用java.lang.reflect包的方法进行类的反射调用时。\n3. 适当初始化一个类的时候，如果发现其父类还没有进行过初始化。\n4. 当虚拟机启动时用户指定要执行的主类（main方法所在类）。\n\n\n```\n//被动引用1，引用非直接定义的类的静态字段。\npublic class SuperClass{\n\tstatic{\n\t\tSystem.out.println(\"SuperClass init\");\n\t}\n\tpublic static int value = 123;\n}\n\n\npublic class SubClass extends SuperClass{\n\tstatic{\n\t\tSystem.out.println(\"SubClass init\");\n\t}\n}\n\npublic class NotInitialization{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(SubClass.value);\n\t}\n}\n```\n\n> 结果只触发了父类的初始化，子类不会触发初始化，至于子类的加载和验证，取决于虚拟机的具体实现，sun hotspot可以使用-XX：+TraceClassLoading追踪查看。\n\n\n```\n//被动引用2，通过数组定义引用类。\npublic class NotInitialization1{\n\tpublic static void main(String[] args){\n\t\tSuperClass[] ca = new SuperClass[10];\n\t} \n}\n```\n> 输出为空，表明未初始化类。\n> 对于数组，虚拟机自动生成了一个直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。\n\n\n```\n//被动引用3，常量在编译阶段会存入调用类的常量池中，本质上没用直接引用到定义常量的类，所以不会被初始化。\npublic class ConstClass{\n\tstatic {\n\t\tSystem.out.println(\"ConstClass init\");\n\t} \n\tpublic static final String HELLOSTRING = \"jinelei\"; \n}\n\npublic class NotInitialization2{ \n\tpublic static void main(String[] args){\n\t\tSystem.out.println(ConstClass.HELLOSTRING);\n\t} \n}\n```\n\n\n#### 接口的初始化\n\n接口的加载过程与类只有一点不同：类要求子类初始化之前，父类必须全部初始化。借口在初始化时并不要求其父接口全部都完成初始化。只有在真正调用父接口的时候才会进行初始化。  \n接口中不能使用static{}来输出类加载信息，但是编译器会为接口生成<clinit>()的类构造器，用于初始化接口中所定义的成员变量。\n","tags":["学习笔记"],"categories":["Java","VirtualMachine"]},{"title":"类加载的过程","url":"/2017/08/02/learn-jvm-chapter7.3/","content":"\n#### 类加载的过程\n类加载包括：加载、验证、准备、解析、初始化五个阶段。\n\n#### 加载\n加载阶段虚拟机要完成以下三件事情：\n1. 通过一个类的全限定名类获取定义类的二进制字节流。\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n3. 在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。\n\n> java 并不对一个类的全限定名的取得作出具体的要求。 通常有以下几种常见方式：  \n- 从ZIP包中读取，常见的JAR、WAR、EAR。  \n- 从网络中获取，常见的Applet。  \n- 运行时计算生成，常见于动态代理技术。  \n- 由其他文件生成，常见于JSP应用。  \n- 从数据库中读取，较少见在中间服务器分发程序代码。\n- ......\n\n\n#### 验证\n验证是连接的第一步，目的是确保CLass文件流中包含的信息合法无害。\njava虚拟机规范对于这个重要的步骤的指导和限制比较笼统，只有一句如果验证到输入的字节流不符合Class文件的存储格式，则抛出java.lang.VeriflyError异常或其子类异常。具体检查根据虚拟机不同实现有所差别，但是大致分为以下四个阶段：文件格式验证、元数据验证、字节码验证、符号验证。  \n\n##### 文件格式验证\n- 是否以魔数oxCAFEBABE开头。\n- 主次版本号是否在当前虚拟机能够处理的范围内。\n- 常量池的常量中是否有不被支持的常量类型。（检查常量tag标志）。\n- 指向常量的各种索引值中是否有只想不存在的常量或不符合类型的常量。\n- CONSTANT_Utf8-info型的常量中是否有不符合UTF8编码的数据。\n- Class文件中的各个部分及文件本身是否有被删除的或附加的其他信息。\n- ......  \n\n##### 元数据验证\n这一阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范，可能包含以下验证：\n- 这个类是否有父类（除Object外）。\n- 这个类的父类是否继承了不允许被继承的类（final类）。\n- 如果这个类不是抽象类，是否是现在父类或接口中要求的所有方法。\n- 类中的字段、方法是否与父类产生矛盾（覆盖final字段、不符合规则的重载等）。  \n\n##### 字节码验证\n这一阶段是整个验证过程中的最复杂的一个阶段。  \n主要是对数据流和控制流分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。保证不会出现例如以下的情况：  \n- 保证在操作栈中放入了一个int类型的数据，使用时却以long类型来加载入本地变量表中。  \n- 保证跳转指令不会跳到方法体以外的字节码指令上。  \n- 保证方法体中的类型转换是有效的。\n- ......\n\n > 在JDK1.6之后的javac编译器中进行了一项优化，给方法体的Code属性中添加了StackMapTree属性，这项属性描述了方法体中所有基本快开始是本地变量表和操作栈应有的状态，。  \n HotSpot中提供了-XX: -UseSplitVerifier来关闭优化，或者使用 -XX： +FailOverToOldVerifier要求在类型推到失败时退回到旧的类型推导方式进行校验。  \n 在JDK 1.7之后，对于主版本号大于50的CLass文件，不允许退回旧的类型推导验证。\n\n##### 符号引用验证\n最后一个阶段时将符号引用转化为直接引用，这个转化动作将在连接的第三个阶段--解析阶段发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常包括以下内容：\n- 符号引用中通过字符串描述的全限定名是否能找到对应的类。\n- 在指定类中是否存在符合方法的字段描述符即简单名称所描述的方法和字段。\n- 符号引用中的类、字段和方法的访问性是否可以被当前类所访问。\n- ......\n> 如果无法通过验证，将会抛出java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。\n\n>验证阶段是非必要阶段，如果可以保证全部可信，可以使用-Xverify: none来跳过验证他。\n","tags":["学习笔记"],"categories":["Java","VirtualMachine"]},{"title":"Linux实用工具 xset","url":"/2017/07/30/xset-cookbook/","content":"\nxset是linux中设置X-Window的实用工具。\n\n---\n-display display  \n指定这个server用在哪个display上。\n\n---\nb  \n指定开关机的提示音，使用[+/-]前缀，或者[on/off]后缀。\n> xset +b  \n> xset b on\n\n---\nbc  \n调试兼容模式开关，使用[+/-]前缀。  \n\n---\nc  \n按键声音开关，使用[+/-]前缀，或者[on/off]后缀。\n\n---\ndmps  \n节能之星开关，使用[+/-]前缀。\n\ndmps flags...\n> force 强制进入某种状态。standby、suspend、off、on。\n>> xset dmps force suspend\n\n> 数值参数：[standby] [suspend] [off]\n>> 设置0禁用。\n\n---\nfp=\n字体路径。\n> fp default   设置为服务器默认。\n\nfp rehash\n> 刷新font database。 \n\n---\nled  \n设置键盘led，使用[+/-]前缀，数值参数1-32。支持XKB名称。\n","tags":["备忘录"],"categories":["Linux"]},{"title":"Unix 进程控制 fork、vfork","url":"/2017/07/27/unix-process-control/","content":"\n#### 概要\n进程控制：创建新进程、执行程序和进程终止。\n进程属性ID：实际、有效和保存的用户和组ID。\n进程控制原语、解释器文件、system函数、进程会计机制。\n\n##### 进程标识符\n每个进程都有一个非负整数表示唯一的进程ID。进程ID是唯一的（常用来保证唯一性）、可重用的（系统通常采用延迟重用算法，以避免将新进程误认为使用同一ID的已终止的先前进程）。\n> 特殊进程：  \n> 调度进程（ID为0）：常常为成为交换进程（swapper）。作为内核的一部分，并不执行任何磁盘上的程序。因此称之为系统进程。  \n> init进程（ID为1）：在自举过程中由内核调用（早期系统版本中是/etc/init，在较新版本中是/sbin/init）。此进程负责在自举内核后启动一个unix系统，init通常读取与系统相关的初始化文件（/etc/rc*、/etc/inittab、/etc/init.d），再将系统引导至一个（例如多用户）状态。  \n>\n>> |调度进程和init进程比较|终止|进程类别|\n>> |:---|:---|:---|\n>> |调度进程|会终止|内核进程|\n>> |init进程|不会终止|用户进程（以超级用户特权运行）|\n>\n> 页守护进程（ID为2）：特殊系统实现，用来支持虚拟存储系统的分页操作。\n\n```\n#include <unistd.h>\npid_t getpid(void);     //返回值：调用进程的进程ID\npid_t getppid(void);    //返回值：调用进程的父进程ID\nuid_t getuid(void);     //返回值：调用进程的实际用户ID\nuid_t geteuid(void);    //返回值：调用进程的有效用户ID\ngid_t getgid(void);     //返回值：调用进程的实际组ID\ngid_t getegid(void);    //返回值：调用进程的有效组ID\n以上函数均无出错返回。\n```\n\n##### fork函数\n```\n#include <unistd.h>\npid_t fork(void);       //返回值：子进程中返回0，父进程中返回子进程ID，出错返回-1\n```\nfork函数调用一次，返回两次，根据返回进程ID来区别父子进程。\n> 子进程中调用`getppid`来获得父进程ID。  \n> 父进程无法获取其所有的子进程ID。\n\n父子进程继续执行forrk之后的指令，子进程是父进程的副本。子进程拥有父进程的数据空间、堆和栈的副本。这里拥有并不共享。父子进程只共享正文段。  \n> 写时复制技术（Copy-On-Write）：由于很多实现子进程并不执行父进程的数据段、堆和栈，所以实现时内核只是将其访问权限改为只读，并不直接复制，当其中任意一个试图修改是，内核才会将修改区域的内存制作一个副本。即通常是虚拟存储器系统的一页。\n>> fork函数变体。\n>> Linux 2.4.22提供了新进程创建函数clone(2)系统调用，特点：允许控制父子进程共享段。  \n>> FreeBSD 5.2.1提供了rfork(2)系统调用，类似于Linux的clone。  \n>> Solaris 9提供了两个线程库，一个用于POSIX线程（pthread)，另一个用于Solaris线程。\n\n```\n#include <stdio.h>\n#include <unistd.h>\n\nint glob = 6;\nchar buf[] = \"a write to stdout\\n\";\n\nint main(int argc, char* argv[])\n{\n\n    int var;\n    pid_t pid;\n\n    var = 88;\n    if(write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)\n    {\n        printf(\"write error\\n\");\n    }\n    printf(\"before fork\\n\");\n\n    if((pid = fork()) < 0)\n    {\n        printf(\"fork error\\n\");\n    }\n    else if( pid == 0 )\n    {\n        printf(\"children process\\t\\t\");\n        glob++;\n        var++;\n    }\n    else{\n        printf(\"father process  \\t\\t\");\n        sleep(2);\n    }\n\n    printf(\"pid = %d, blob = %d, var = %d\\n\", getpid(), glob, var);\n\n    exit(0);\n}  \n```\n输出结果：\n```\na write to stdout\nbefore fork\nchildren process                pid = 25767, blob = 7, var = 89\nfather process                  pid = 25766, blob = 6, var = 88\n```\n\n> 可见父子进程变量并不共享。  \n> 父子进程的调用顺序取决于内核所使用的调度算法。可以使用进程间通信保证父子进程同步。  \n>> strlen和sizeof比较： strlen不包括终止null字节长度，sizeof包括终止null字节长度；strlen属于函数调用，sizeof属于编译时已知。  \n> write函数：write函数不带缓冲，在fork之前调用write函数是为了保证缓冲区干净。  \n>> 子进程会复制父进程缓冲区。  \n>> 子进程复制父进程所有打开的文件描述符。\n>>> fork之后处理文件描述符的两种常见情况：  \n>>> 1. 父进程等待子进程完成。当子进程终止后，所有进行过读、写操作的任一文件描述符的文件偏移量都已执行了相应的更新。\n>>> 2. 父子进程各自执行不同的程序段。在fork之后，父子进程各自关闭它们不需要的文件描述符，这样的不会干扰对方使用的文件描述符。通常在网络服务进程中使用此方法。  \n>\n>> 其他被子进程继承的属性：\n>> * 实际用户ID、实际组ID、有效用户ID、有效组ID。\n>> * 附加组ID。\n>>* 进程组ID。\n>>* 会话ID。\n>>* 控制终端。\n>>* 设置用户ID和设置组ID标志。\n>>* 当前工作目录。\n>>* 根目录。\n>>* 文件模式创建屏蔽字。\n>>* 信号屏蔽和安排。\n>>* 针对任一打开文件描述符的在执行时关闭标志。\n>>* 环境。\n>>* 连接的共享存储段。\n>>* 存储映射。\n>>* 资源限制。\n>\n>> 父子进程之间的区别：\n>>>* fork返回值。\n>>>* 进程ID不同。\n>>>* 进程父ID不同：子进程父ID是创建它的进程ID，父进程的父ID不变。\n>>>* 子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime均被设置为0。\n>>>* 父进程设置的文件锁不被继承。\n>>>* 子进程的未处理的闹钟被清除。\n>>>* 子进程未处理的信号集被设置为空集。\n>\n>>fork失败的主要原因：系统有太多的进程，或者该实际用户ID的进程综述超过了系统限制。（PS：CHILD_MAX控制了每个实际用户ID在任意时刻可具有的最大进程数）。\n>\n\n##### vfork函数\nvfork用于创建一个新进程，二该新进程的目的是exec一个新程序。\nfork、vfork区别：vfork保证子进程现运行，在它调用exec或exit之后父进程才运行（可能导致死锁）；vfork并不完全复制父进程的地址空间。  \n\n|fork、vfork比较|复制|执行顺序|\n|:---|:---|:---|\n|fork|完全复制|不保证|\n|vfork|不完全复制（子进程会立刻调用exec或exit）|子进程先行，子进程exec或exit后，父进程再运行|\n\n> 在子进程exec或exit之前，子进程运行在父进程的地址空间。  \n\n```\n#include <stdio.h>\n#include <unistd.h>\n\nint glob = 6;\nchar buf[] = \"a write to stdout\\n\";\n\nint main(int argc, char* argv[])\n{\n\n    int var;\n    pid_t pid;\n\n    var = 88;\n    if(write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)\n    {\n        printf(\"write error\\n\");\n    }\n    printf(\"before fork\\n\");\n\n    if((pid = vfork()) < 0)\n    {\n        printf(\"fork error\\n\");\n    }\n    else if( pid == 0 )\n    {\n        printf(\"children process\\t\\t\");\n        glob++;\n        var++;\n        printf(\"pid = %d, blob = %d, var = %d\\n\", getpid(), glob, var);\n        _exit(0);\n    }\n    else{\n        printf(\"father process  \\t\\t\");\n        printf(\"pid = %d, blob = %d, var = %d\\n\", getpid(), glob, var);\n        //sleep(2);\n    }\n\n\n    exit(0);\n}\n\n```\n\n执行结果\n\n```\na write to stdout\nbefore fork\nchildren process                pid = 29968, blob = 7, var = 89\nfather process                  pid = 29967, blob = 7, var = 89\n```\n>可以看出在子进程执行_exit(0)之前，父子进程处于同一片地址空间。\n>> exit和_exit(0)的区别: _exit(0)并不执行标准I/O缓冲的冲洗操作;exit实现了冲洗所有标准I/O流.也可能实现了关闭标准I/O流(取决于系统实现,大多数现代exit实现军不在关闭流,因为进程终止前,内核将关闭所有已打开的文件描述符.在库中关闭没有必要了).\n","tags":["学习笔记"],"categories":["Linux"]},{"title":"Unix 进程终止 wait waitpid","url":"/2017/07/27/unix-process-terminal/","content":"\n#### 概要\n进程终止共有8种方式，其中5种为正常终止。\n\n\n\n- 正常终止：\n1. 从main返回。\n2. 调用exit。\n3. 调用_exit或_Exit。\n4. 最后一个线程从其启动例程返回。\n5. 最后一个线程调用pthread_exit。\n- 异常终止：\n6. 调用abort。\n7. 接收到一个新号并终止。\n7. 最后一个线程对取消请求做出响应。\n\n---\n#### exit()、_exit()和_Exit()\n\n```\n#include <stdlib.h>\nvoid exit(int status);\nvoid _Exit(int status);\n#include <unistd.h>\nvoid _exit(int status);\n```\n\n> - 使用不同的头文件的原因是：exit和_Exit是有ISO C说明的，而_exit则是由POSIX.1说明的。  \n> - _exit和_Exit立即进入内核，而exit则先执行一些清理处理后(包括执行各种终止处理程序，关闭所有标准I/O流等)进入内核。\n>> main执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0(ISO C 1999版引入的，之前的返回值是未定义的，任意值).\n\n##### 正常终止：\n\n- 在main函数中执行return语句，等效调用exit。\n- 调用exit函数（ISO C定义），exit函数将会调用各种终止处理程序（atexit函数登记的），然后关闭标准I/O流等。由于ISO C并不处理文件描述符、多进程以及作业控制，所以对于UNIX来说是不完整的。\n- 调用_exit或_Exit函数（ISO C），目的是为晋城提供一种无序运行终止处理程序或信号处理程序而终止的方法。是否对标准I/O流进程冲洗，取决于具体的实现。（Unix中，_exit和_Exit是同义的，不冲洗标准I/O流）。\n- 进程的最后一个线程从其启动例程中执行返回语句。但是该返回值不会被作为进程的返回值。其返回值为0.\n- 进程的最后一个县城嗲聘用pthrea_exit函数，同前一项已知，终止状态始终为0。\n\n##### 异常终止：\n- 调用abort，它将会产生SIGABRT信号。\n- 当进程接收到某些信号时，信号可有进程自身（如调用abort函数）、其他进程或内核产生。\n- 最后一个线程对“取消”请求做出相应。按系统默认，“取消”一延迟方式发生。即，被要求取消的线程将会等待一段时间才会终止。\n\n---\n\n### atexit()函数\n标准ISO C规定，一个进程可以登记多达32个函数，这些函数将由exit自动调用，我们称这些函数为终止处理程序（exit handler），并调用atexit函数来登记这些函数，执行顺序与登记顺序相反。\n\n```\n#include <stdlib.h>\nint atexit(void (*func)(void));     //返回值：成功返回0，出错非0值\n```\n> 调用顺序与登记顺序相反，同一函数多次登记也会被多次调用。\n\n---\n\n#### 父进程在子进程之前终止（孤儿进程领养）\n内核在一个进程终止时，内核逐个检查所有活动进程的父进程是否为将要终止的进程，如果是，则将该进程的父进程更改为1（init进程）。\n\n#### 子进程在父进程之前终止\n内核为每个终止的子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。其中至少包括：进程ID、进程终止状态、进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其打开的所有文件。在Unix术语中，称一个已经终止的、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程为***僵死进程***（zombie）。ps(1)打印状态为Z。\n> init进程将会调用其wait函数以避免产生僵死进程。\n\n#### wait、waitpid\n\n对于任意一种终止情形，内核产生一个指示其异常终止原因的终止状态，在任意情况下，该终止的父进程都能调用wait或waitpid获取其终止状态。\n> 退出状态（_exit、_Exit或main的返回值），在最后调用_Exit时，内核将退出状态转换成终止状态。\n\n当一个进程正常或异常终止时，内核就会向其父进程发送SIGCHLD信号。因为子进程终止是一个异步事件，所以这种信号也是异步通知，父进程可以选择忽略，或是处理该信号（信号处理程序）。系统默认动作是忽略它。\n\n父进程调用wait或watipid可能出现以下3种情况：\n- 如果子进程还在运行，则阻塞。\n- 如果一个子进程已终止，正等待的父进程获取其终止状态，则取得该子进程的终止状态后立刻返回。\n- 如果没有任何子进程，则立即出错返回。\n\n```\n#include <sys/wait.h>\npid_t wait(int *statloc);\npid_t waitpid(pid_t pid, int *statloc, int options);\n//返回值：成功返回进程ID，0,，出错返回-1\n```\n\n这两个函数的区别如下：\n- 在一个子进程终止前，wait使其调用者阻塞，而waitpif有一个选项，可以使得调用者不阻塞。\n- waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。\n\n这两个函数均使用参数statloc这个整形指针作为返回值，如果statloc不是空指针，则将返回值存储在指针指向的单元内，如果不关心终止状态，则可将此参数设置为空指针。\n返回状态由<sys/wait.h>中提供的各个宏来查看。\n\n|宏|说明|\n|---|---|\n|WIFEXITED(status)|如果为正常终止则为真，接下来可用WEXITSTATUS(status)，取得进程传给exit、_exit或_Exit参数的低8位|\n|WIFSIGNALED(status)|如果为异常终止子进程返回的状态则为真。接下来可可以用WTERMSIG(status)，取得子进程终止的信号编号。某些系统定义了WCOREDUMP(status)来检查进程产生的core文件，有则返回真。|\n|WIFSTOPED(status)|如果为当前暂停的子进程的返回状态，则为真，接下来可以用WSTOPSIG(status)来取得子进程的信号编号。|\n|WIFCONTINUED(status)| 如果是在作业控制暂停后已经继续的子进程返回了状态，则为真。（POSIX.1的XSI扩展，仅用于waitpid )|\n\n```\n#include <sys/wait>\nvoid pr_exit(int status)\n{\n    if(WIFEXITED(status))\n        printf(\"normal termination, exit status = %d\\n\", WEXITSTATUS(status));\n    else if(WIFSIGNALED(status))\n        PRINTF(\"abnormal termination, signal number = %d\\n\",\n        WTERMSIG(status));\n    #ifdef WCOREDUMP\n        WCOREDUMP(status) ? \" (core file generated)\" : \"\");\n    #else\n        \"\")\n    #endif\n    else if(WIFSTOPPED(status))\n        printf(\"child stopped, signal number = %d\\n\", WSTOPSIG(status));\n}\n```\n> 信号编号可以查<signal.h>头文件。\n\n未完待续...\n","tags":["学习笔记"],"categories":["Linux"]},{"title":"正则表达式基础 元字符","url":"/2017/07/26/learn-regex-chapter2/","content":"\n* #### 元字符: ***$()*+.?[\\^{|***\n  元字符：`$()*+.?[\\^{|`共12个。\n  >字符]只有出现在未转义的[之后才是元字符。同理}也是。  \n\n* #### 块转义（Perl、PCRE和Java都支持 ***<\\Q>*** 和 ***<\\E>***）\n  > <\\Q>和<\\E>，在此之间的所有元字符都作为普通字符使用。  \n  `\\Q!@#$%^&*()_+\\E`\n* #### 忽略大小写 ***<(?i)>***\n  > `(?i)asdf`\n* #### 匹配不可打印字符\n  > 包括：*振铃符（bell）、转义符（escape）、换页符（formfeed）、换行符（line feed）、回车符（carriage return）、水平制表符（horizontal tab）和垂直制表符（vertical tab）*。对应的ASCII编码是：07、1B、0C、0A、0D、09、0B。\n  >> 不可打印字符变体：Ctrl+字符键对应表示为 **<\\cA>到<\\cZ>**，其中c字符必须为小写。\n\n  |表示|含义|十六进制表示|正则流派|\n  |---|---|---|---|\n  |<\\a>|振铃|0x07|.NET、Java、PCRE、Perl、Python、Ruby|\n  |<\\e>|转义|0x1B|.NET、Java、PCRE、Perl、Ruby|\n  |<\\f>|换页|0x0C|.NET、Java、JavaScript、PCRE、Perl、Python、Ruby|\n  |<\\n>|换行|0x0A|.NET、Java、JavaScript、PCRE、Perl、Python、Ruby|\n  |<\\r>|回车|0x0D|.NET、Java、JavaScript、PCRE、Perl、Python、Ruby|\n  |<\\t>|水平制表符|0x09|.NET、Java、JavaScript、PCRE、Perl、Python、Ruby|\n  |<\\v>|垂直制表符|0x0B|.NET、Java、JavaScript、PCRE、Perl、Python、Ruby|\n","tags":["学习笔记"],"categories":["Regex"]},{"title":"正则表达式基础 字符组","url":"/2017/07/26/learn-regex-chapter2_3/","content":"\n\n\n#### 使用方括号的表示法被称为 **字符组(character class)**。\n> 每组可以匹配一个字符。字符之间相互独立。  \n>  在一个字符组中，只有4个字符拥有特殊功能：**\\ 、^ 、- 、]**。所有其他字符均视为字面量。\n>> 在Java和.Net中，<]>也是元字符。  \n\n>> <\\\\>：在字符组中使用正则表达式记号，如<\\r>、<\\n>。\n>> <->：连字符将创建一个范围，该范围包括连字符之前的字符、连字符之后的字符，以及这之间的所有字符。如[A-z]、[a-z]、[A-Z]，注意[z-a]这样的反向范围是不允许的。\n>>> 范围表示的变体：<\\d>、<\\D>、<\\w>、<\\W>、<\\s>、<\\S>。  \n>>>\n>>> |标识|表示范围|\n>>> |---|---|\n>>> |\\w|字母、数字、下划线|\n>>> |\\W|与\\w相反|\n>>> |\\d|数字|\n>>> |\\D|与\\d相反|\n>>> |\\s|空格、换行符、制表符|\n>>> |\\S|与\\s相反|\n\n#### 更多特性\n- .NET字符组补集。\n  > `<[class-[substract]]>`，例如：[a-zA-Z0-9-[g-zG-Z]]，结果集为：任意字符数字减去从g到z的所有字母。\n- Java字符组并集、交集和补集。  \n  > `<[class1[class2]]`，并集  \n  > `<[class1&&[class2]]`，交集  \n  > `<[class1&&[^class2]]`，补集  \n","tags":["学习笔记"],"categories":["Regex"]},{"title":"虚拟机主要组成部分","url":"/2017/07/25/learn-jvm-chapter2/","content":"\n#### JAVA虚拟机内存划分为以下几个运行时数据区域：  \n1. 程序计数器\n2. Java虚拟机栈\n3. 本地方法栈\n4. Java堆\n5. 方法区\n6. 运行时常量池\n7. 直接内存\n\n| 区域 | 线程可见性 | 作用 | 异常 |\n| :--- | :--- | :--- | :--- |\n| 程序计数器 | - | 当前线程所执行字节码指示器 | 无 |\n| Java虚拟机栈 | 线程私有 |Java方法的内存模型|OOM、SOF|\n| 本地方法栈|线程私有|为Native方法服务|OOM、SOF|\n| java堆|线程共享|存放对象实例|OOM|\n| 方法区|线程共享|存放类信息、常量、静态变量、编译后代码|OOM|\n| 运行时常量池|线程共享|Class中的常量池|OOM|\n| 直接内存|-|直接分配内存|OOM|\n\n\n#### 程序计数器\n\n> 每个线程都拥有独立的程序计数器。是线程私有的\n>> 如果正在执行的时Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。\n>\n>> 如果正在执行的时Native方法，这个计数器值则为空（Undefined）\n#### Java虚拟机栈\n> 线程私有的。生命周期和鲜橙相同。\n> 虚拟机栈描述的是Java方法执行的内存模型。\n>> 每个方法被执行的时候都会常见一个栈帧。  \n>\n>> 用于存储局部变量表、操作栈、动态链接、方法出口等信息。  \n>\n>> 方法执行过程对应栈帧入栈出栈的过程。  \n* ##### 局部变量表\n> 存放编译期克制的各种基本数据类型（boolean、byte、short、int、float、long、double）、对象引用（reference类型，不等同于对象本身，具体实现由虚拟机决定，可能是指向对象起始地址的引用指针也可能是指向一个对象的句柄或其他与此对象相关的位置）、returnAddress类型（指向一条字节码指令地址）。\n> 局部变量表所需空间在编译期完成分配。运行期间不会改变大小。\n> 异常：\n>> StackOverflowError：线程请求的栈深度大于虚拟机多允许的深度。  \n>> OutOfMemoryError：动态扩展时，当无法申请足够的内存时（虚拟机规范中允许动态扩展和固定长度的虚拟机栈）。\n#### 本地方法栈\n> 与虚拟机栈相似，不同的是虚拟机栈为java方法（也就是字节码）服务，本地方法栈为Native方法服务。\n>> Sun Hotspot 直接把虚拟机栈和本地方法栈合二为一。  \n> 异常： OOF和SOF。\n#### java堆  \n  java堆是虚拟机所管理的内存中最大的一块。\n> java堆被所有线程共享。  \n> 存在的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n>> 规范的描述是：所有的随想实例以及数组都要在堆上分配，但是随着JIT编译期的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术导致一些微妙的变化发生，所有对象都分配在对象也变得不那么“绝对”了。  \n* java堆分类：\n* 新生代\n    * Eden空间\n    * From Survivor空间\n    * To Survivor空间\n* 老年代\n> 异常：OOM\n> 配置：-Xmx和-Xms\n#### 方法区\n> 被所有线程共享\n> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n> 别名 Non-Heap，又称永久代。\n> 异常：OOM\n#### 运行时常量池 （属于方法区）\n> 运行时常量池是方法去的一部分。\n> 用于存放编译后的Class文件中的常量池（包括编译期生成的各种字面量和符号引用）。\n> 运行时常量池具备动态性：运行期间也能将新的常量放到常量池中，例如String类的intern()方法。\n> 异常：OOM\n---\n#### 直接内存 （不属于虚拟机内存）\n> 并不属于java虚拟机规范定义的内存区域，异常：OOM。\n> NIO中可以直接分配内存，使用DirectByBuffer对象进行操作。\n","tags":["学习笔记"],"categories":["Java","VirtualMachine"]},{"title":"shell统计代码字数","url":"/2017/06/01/shell-count-word/","content":"\n```\n#!/bin/bash\ndir=\"/home/jinelei/Projects/IdeaProjects/Web/JinLive/src\"\ntmp_dir=\"\"\n\njava_file=0\nxml_file=0\nftl_file=0\nproperties_file=0\n\njava_file_l=0\nxml_file_l=0\nftl_file_l=0\nproperties_file_l=0\n\njava_file_w=0\nxml_file_w=0\nftl_file_w=0\nproperties_file_w=0\n\njava_file_c=0\nxml_file_c=0\nftl_file_c=0\nproperties_file_c=0\n\nfor file in `ls -R $dir`\ndo\n    if [ -n \"`echo $file|sed -n \"/^.*:\\$/p\"`\" ]; then \n        #echo -e $file;\n        tmp_dir=${file%%:}\n    elif [ -n \"`echo $file|sed -n \"/^.*\\.java\\$/p\"`\" ]; then\n        tmp_w=`cat \"$tmp_dir/$file\" |wc -w`\n        java_file_w=`expr $java_file_w + $tmp_w`\n        tmp_c=`cat \"$tmp_dir/$file\" |wc -c`\n        java_file_c=`expr $java_file_c + $tmp_c`\n        tmp_l=`cat \"$tmp_dir/$file\" |wc -l`\n        java_file_l=`expr $java_file_l + $tmp_l`\n        java_file=`expr $java_file + 1`\n        #echo -e  \"linecount: $tmp\\t\\tfilename: $file\\t\\t\\tdirectoryname: ${tmp_dir##${dir}}\"\n    elif [ -n \"`echo $file|sed -n \"/^.*\\.xml\\$/p\"`\" ]; then\n        tmp_w=`cat \"$tmp_dir/$file\" |wc -w`\n        xml_file_w=`expr $xml_file_w + $tmp_w`\n        tmp_c=`cat \"$tmp_dir/$file\" |wc -c`\n        xml_file_c=`expr $xml_file_c + $tmp_c`\n        tmp_l=`cat \"$tmp_dir/$file\" |wc -l`\n        xml_file_l=`expr $xml_file_l + $tmp_l`\n        xml_file=`expr $xml_file + 1`\n        #echo -e  \"linecount: $tmp\\t\\tfilename: $file\\t\\t\\tdirectoryname: ${tmp_dir##${dir}}\"\n    elif [ -n \"`echo $file|sed -n \"/^.*\\.ftl\\$/p\"`\" ]; then\n        tmp_w=`cat \"$tmp_dir/$file\" |wc -w`\n        ftl_file_w=`expr $ftl_file_w + $tmp_w`\n        tmp_c=`cat \"$tmp_dir/$file\" |wc -c`\n        ftl_file_c=`expr $ftl_file_c + $tmp_c`\n        tmp_l=`cat \"$tmp_dir/$file\" |wc -l`\n        ftl_file_l=`expr $ftl_file_l + $tmp_l`\n        ftl_file=`expr $ftl_file + 1`\n        #echo -e  \"linecount: $tmp\\t\\tfilename: $file\\t\\t\\tdirectoryname: ${tmp_dir##${dir}}\"\n    elif [ -n \"`echo $file|sed -n \"/^.*\\.properties\\$/p\"`\" ]; then\n        tmp_w=`cat \"$tmp_dir/$file\" |wc -w`\n        properties_file_w=`expr $properties_file_w + $tmp_w`\n        tmp_c=`cat \"$tmp_dir/$file\" |wc -c`\n        properties_file_c=`expr $properties_file_c + $tmp_c`\n        tmp_l=`cat \"$tmp_dir/$file\" |wc -l`\n        properties_file_l=`expr $properties_file_l + $tmp_l`\n        properties_file=`expr $properties_file + 1`\n        #echo -e  \"linecount: $tmp\\t\\tfilename: $file\\t\\t\\tdirectoryname: ${tmp_dir##${dir}}\"\n    fi\ndone\n\necho -e \"result:\" \necho -e \"java file:\\t$java_file\\t\\tjava line:\\t$java_file_l\\t\\tjava word:\\t$java_file_w\\t\\tjava char:\\t$java_file_c\" \necho -e \"xml file:\\t$xml_file\\t\\txml line:\\t$xml_file_l\\t\\txml word:\\t$xml_file_w\\t\\txml char:\\t$xml_file_c\" \necho -e \"ftl file:\\t$ftl_file\\t\\tftl line:\\t$ftl_file_l\\t\\tftl word:\\t$ftl_file_w\\t\\tftl char:\\t$ftl_file_c\" \necho -e \"prop file:\\t$properties_file\\t\\tprop line:\\t$properties_file_l\\t\\tprop word:\\t$properties_file_w\\t\\tprop char:\\t$properties_file_c\"\necho -e \"total file:\\t`expr $java_file + $xml_file + $ftl_file + $properties_file`\\t\\ttotal line:\\t`expr $java_file_l + $xml_file_l + $ftl_file_l + $properties_file_l`\\t\\ttotal word:\\t`expr $java_file_w + $xml_file_w + $ftl_file_w + $properties_file_w`\\t\\ttotal char:\\t`expr $java_file_c + $xml_file_c + $ftl_file_c + $properties_file_c`\"\n```\n","tags":["备忘录"],"categories":["Linux"]}]