---
title: 虚拟机主要组成部分
date: 2017-07-25 09:00:00
categories:
  - Java
  - VirtualMachine
---

#### JAVA虚拟机内存划分为以下几个运行时数据区域：  
1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
5. 方法区
6. 运行时常量池
7. 直接内存

| 区域 | 线程可见性 | 作用 | 异常 |
| :--- | :--- | :--- | :--- |
| 程序计数器 | - | 当前线程所执行字节码指示器 | 无 |
| Java虚拟机栈 | 线程私有 |Java方法的内存模型|OOM、SOF|
| 本地方法栈|线程私有|为Native方法服务|OOM、SOF|
| java堆|线程共享|存放对象实例|OOM|
| 方法区|线程共享|存放类信息、常量、静态变量、编译后代码|OOM|
| 运行时常量池|线程共享|Class中的常量池|OOM|
| 直接内存|-|直接分配内存|OOM|


#### 程序计数器

> 每个线程都拥有独立的程序计数器。是线程私有的
>> 如果正在执行的时Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。
>
>> 如果正在执行的时Native方法，这个计数器值则为空（Undefined）
#### Java虚拟机栈
> 线程私有的。生命周期和鲜橙相同。
> 虚拟机栈描述的是Java方法执行的内存模型。
>> 每个方法被执行的时候都会常见一个栈帧。  
>
>> 用于存储局部变量表、操作栈、动态链接、方法出口等信息。  
>
>> 方法执行过程对应栈帧入栈出栈的过程。  
* ##### 局部变量表
> 存放编译期克制的各种基本数据类型（boolean、byte、short、int、float、long、double）、对象引用（reference类型，不等同于对象本身，具体实现由虚拟机决定，可能是指向对象起始地址的引用指针也可能是指向一个对象的句柄或其他与此对象相关的位置）、returnAddress类型（指向一条字节码指令地址）。
> 局部变量表所需空间在编译期完成分配。运行期间不会改变大小。
> 异常：
>> StackOverflowError：线程请求的栈深度大于虚拟机多允许的深度。  
>> OutOfMemoryError：动态扩展时，当无法申请足够的内存时（虚拟机规范中允许动态扩展和固定长度的虚拟机栈）。
#### 本地方法栈
> 与虚拟机栈相似，不同的是虚拟机栈为java方法（也就是字节码）服务，本地方法栈为Native方法服务。
>> Sun Hotspot 直接把虚拟机栈和本地方法栈合二为一。  
> 异常： OOF和SOF。
#### java堆  
  java堆是虚拟机所管理的内存中最大的一块。
> java堆被所有线程共享。  
> 存在的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
>> 规范的描述是：所有的随想实例以及数组都要在堆上分配，但是随着JIT编译期的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术导致一些微妙的变化发生，所有对象都分配在对象也变得不那么“绝对”了。  
* java堆分类：
* 新生代
    * Eden空间
    * From Survivor空间
    * To Survivor空间
* 老年代
> 异常：OOM
> 配置：-Xmx和-Xms
#### 方法区
> 被所有线程共享
> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
> 别名 Non-Heap，又称永久代。
> 异常：OOM
#### 运行时常量池 （属于方法区）
> 运行时常量池是方法去的一部分。
> 用于存放编译后的Class文件中的常量池（包括编译期生成的各种字面量和符号引用）。
> 运行时常量池具备动态性：运行期间也能将新的常量放到常量池中，例如String类的intern()方法。
> 异常：OOM
---
#### 直接内存 （不属于虚拟机内存）
> 并不属于java虚拟机规范定义的内存区域，异常：OOM。
> NIO中可以直接分配内存，使用DirectByBuffer对象进行操作。
