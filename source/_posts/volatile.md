---
title: volatile
date: 2018-12-01 09:00:00
---

重排序是指编译器和处理器为了优化程序性能二队指令序列进行重新排序的一种手段。

- ### 数据依赖性
如果两个操作访问同一个变量，且两个操作中的一个为写操作。此时就存在数据依赖性。（读写顺序会影响结果）
- #### as-if-serial语义
不管怎么重排序编译器、runtime和处理器都必须遵守as-if-serial语义。这个特性使得单线程程序看起来是按顺序执行的。
在happens-before规则中，JMM会进行拓扑排序来推导执行顺序。

- 未同步程序在JMM喝顺序一致性模型中的差异
1. 顺序一致性模型保证单线程内的操作会按照程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。
2. 顺序一致性模型保证所有线程智能看到一只的操作执行顺序，而JMM不保证所有线程能看到一只的操作顺序。
3. JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读、写都具有原子性。
> 第三个差异与处理器总显得工作机制密切相关。在计算机中，数据通过总现在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一些列步骤称之为总线事务。总显示无包括读事务和写事务。读事务从内存传递数据到处理器，写事务从处理器出啊地数据到内存，每个事物会读写内存中的一个或多个物理上连续的字。这里的关键是，总线会同步视图并发使用总线的事物。在一个处理器执行总线事务期间，总线会禁止其他的处理器和设备执行内存的读写。（通过总线仲裁来对总线的竞争作出裁决，保证单个总线事务之中的读写具有原子性）。
>> 在一些32位的处理器上，如果要求对64位的数据写操作具有原子性，会有比较大的开销。为了照顾着中处理器，java语言规范鼓励但不强求JVM对64位的变量写操作具有原子性。当JVM在这个处理器上运行时，可能会把一个64位的变量的写操作拆分为两个32位的写操作来执行，这两个写操作可能被分配到不同的总线事务中执行，此时这个写操作将不具有原子性。
>>> 64位变量的读操作都具有原子性。

- ### volatile的内存语义
当生命共享变量为volatile后，对这个变量的读写将会特别。

1. volatile的特性
    1. 可见性：对一个volatile变量的毒，总是能看到人以县城对这个colatile变量最后的写入。
    2. 原子性，对任意单个colatile变量的读写具有原子性，但类似于volatile++这种符合操作不具有原子性。
一个volatile变量的单个读写操作，与一个普通变量的读写操作都是用用一个锁来同步的效果相同。
> 锁的happens-before规则保证释放锁和获得所的两个线程之间的内存可见性，这意味着一个volatile变量的毒，总能考到人以县城对这个volaile变量最后的写入。

2. 从JSR-133 开始，volatile变量的亵渎可以实现线程之间的通信。
从内存语义的角度来说，volatile的读写与锁的释放获取具有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile毒与锁的获取有相同的内存语义。

3. volatile写-读的内存语义
线程在写volatile变量后，会同步到主内存中，
线程在读volatile变量时，JMM会把该新城对应的本地内设置为无效，并从主内存中读取。
> 总结：
> 1. 线程A写一个volatile变量，是指山是线程A项接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。
> 2. 线程B读一个volatile变量，是指上是线程B接收了之前某个线程发出的消息。
> 3. 线程A写一个volatile变量，随后线程B读取了这个变量，实质上是线程A通过主内存项线程B发送消息（volatile变量）。

4. volatile重排序规则

| 是否能重排序 |  | 第二个操作 |  |
| :---: | :---: | :---: | :---: |
| 第一个操作 | 普通 读/写 | volatile 读 | volatile 写 |
| 普通 读/写 |   |  | NO |
| volatile 读 | NO | NO | NO |
| volatile 写 |   | NO | NO |

> JMM采取的是一种保守内存屏障策略
> 1. 在每个volatile写操作前面插入一个StoreStore屏障。
> 2. 在每个volatile写操作后面插入一个StoreLoad屏障。
> 3. 在每个volatile读操作前面插入一个LoadLoad屏障。
> 4. 在每个volatile读操作后面插入一个LoadStore屏障。

>> 锁和volatile的区别：
>> 1. volatile仅仅保证对单个volatile变量读写具有原子性，锁对整个临界区代码的执行具有原子性。
>> 2. 在功能上，锁比volatile更强大。
>> 3. 在可伸缩性和执行性上，volatile比锁更强大。

- ### 个人对volatile的理解
    1. volatile只保证变量的取值、赋值是原子性的
    2.
